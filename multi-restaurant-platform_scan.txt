Project Name: multi-restaurant-platform
Project Summary:
# Multi‑Restaurant Platform

A **modular, container‑ready Spring Boot 3 (Java 21) backend** designed to power multi‑restaurant ordering, management, and (eventually) delivery experiences.

> **Why this repo exists** The author rebuilt the project *from scratch* after an earlier “big‑bang” attempt generated too many errors to untangle.  Everything here is meant to be grown **one small, reviewed step at a time**—you’ll see that philosophy reflected throughout this README.

---

## 1  Features (current & planned)

| Status | Domain                 | Highlights                                                                          |
| ------ | ---------------------- | ----------------------------------------------------------------------------------- |
|  ✅     | **Authentication**     | JWT‑based login / registration, role model (ADMIN, RESTAURANT\_ADMIN, CUSTOMER)     |
|  ✅     | **Restaurant & Menu**  | CRUD for restaurants, categories, items (with media & options)                      |
|  🟡    | **Order Flow**         | Cart → order → status timeline (PLACED → CONFIRMED → PREPARING → READY → DELIVERED) |
|  🟡    | **Payments**           | Stripe integration stub (test keys) with webhook listener                           |
|  🟡    | **WebSocket Printing** | Real‑time receipt / KDS ticket streaming to browser printers                        |
|  🔲    | **Admin Dashboard**    | CMS pages, global config, analytics                                                 |

Legend: ✅ finished · 🟡 in progress · 🔲 not started

---

## 2  Tech Stack

| Layer       | Choice                                   | Notes                                                      |
| ----------- | ---------------------------------------- | ---------------------------------------------------------- |
| Language    | **Java 21**                              | Modern features (records, sealed classes, virtual threads) |
| Framework   | **Spring Boot 3.2.x**                    | Modular (each sub‑module is its own Spring Boot project)   |
[DIR] .
[DIR] backend
[DIR] backend/order
[DIR] backend/order/src
[DIR] backend/order/src/test
[DIR] backend/order/src/test/resources
[DIR] backend/order/src/test/java
[DIR] backend/order/src/main
[DIR] backend/order/src/main/resources
[DIR] backend/order/src/main/java
[DIR] backend/order/src/main/java/com
[DIR] backend/order/src/main/java/com/multirestaurantplatform
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/model
[DIR] backend/restaurant
[DIR] backend/restaurant/src
[DIR] backend/restaurant/src/test
[DIR] backend/restaurant/src/test/resources
[DIR] backend/restaurant/src/test/java
[DIR] backend/restaurant/src/test/java/com
[DIR] backend/restaurant/src/test/java/com/multirestaurantplatform
[DIR] backend/restaurant/src/test/java/com/multirestaurantplatform/restaurant
[DIR] backend/restaurant/src/test/java/com/multirestaurantplatform/restaurant/service
[DIR] backend/restaurant/src/main
[DIR] backend/restaurant/src/main/resources
[DIR] backend/restaurant/src/main/java
[DIR] backend/restaurant/src/main/java/com
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/repository
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/model
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service
[DIR] backend/security
[DIR] backend/security/src
[DIR] backend/security/src/test
[DIR] backend/security/src/test/resources
[DIR] backend/security/src/test/java
[DIR] backend/security/src/main
[DIR] backend/security/src/main/resources
[DIR] backend/security/src/main/java
[DIR] backend/security/src/main/java/com
[DIR] backend/security/src/main/java/com/multirestaurantplatform
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/dto
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/repository
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/config
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/model
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/filter
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/service
[DIR] backend/payment
[DIR] backend/payment/src
[DIR] backend/payment/src/test
[DIR] backend/payment/src/test/resources
[DIR] backend/payment/src/test/java
[DIR] backend/payment/src/main
[DIR] backend/payment/src/main/resources
[DIR] backend/payment/src/main/java
[DIR] backend/admin
[DIR] backend/admin/src
[DIR] backend/admin/src/test
[DIR] backend/admin/src/test/resources
[DIR] backend/admin/src/test/java
[DIR] backend/admin/src/main
[DIR] backend/admin/src/main/resources
[DIR] backend/admin/src/main/java
[DIR] backend/print
[DIR] backend/print/src
[DIR] backend/print/src/test
[DIR] backend/print/src/test/resources
[DIR] backend/print/src/test/java
[DIR] backend/print/src/main
[DIR] backend/print/src/main/resources
[DIR] backend/print/src/main/java
[DIR] backend/common
[DIR] backend/common/src
[DIR] backend/common/src/test
[DIR] backend/common/src/test/resources
[DIR] backend/common/src/test/java
[DIR] backend/common/src/main
[DIR] backend/common/src/main/resources
[DIR] backend/common/src/main/java
[DIR] backend/common/src/main/java/com
[DIR] backend/common/src/main/java/com/multirestaurantplatform
[DIR] backend/common/src/main/java/com/multirestaurantplatform/common
[DIR] backend/common/src/main/java/com/multirestaurantplatform/common/model
[DIR] backend/common/src/main/java/com/multirestaurantplatform/common/exception
[DIR] backend/menu
[DIR] backend/menu/src
[DIR] backend/menu/src/test
[DIR] backend/menu/src/test/resources
[DIR] backend/menu/src/test/java
[DIR] backend/menu/src/test/java/com
[DIR] backend/menu/src/test/java/com/multirestaurantplatform
[DIR] backend/menu/src/test/java/com/multirestaurantplatform/menu
[DIR] backend/menu/src/test/java/com/multirestaurantplatform/menu/service
[DIR] backend/menu/src/main
[DIR] backend/menu/src/main/resources
[DIR] backend/menu/src/main/java
[DIR] backend/menu/src/main/java/com
[DIR] backend/menu/src/main/java/com/multirestaurantplatform
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/dto
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/repository
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/model
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/service
[DIR] backend/api
[DIR] backend/api/src
[DIR] backend/api/src/test
[DIR] backend/api/src/test/resources
[DIR] backend/api/src/test/java
[DIR] backend/api/src/test/java/com
[DIR] backend/api/src/test/java/com/multirestaurantplatform
[DIR] backend/api/src/test/java/com/multirestaurantplatform/api
[DIR] backend/api/src/test/java/com/multirestaurantplatform/api/controller
[DIR] backend/api/src/test/java/com/multirestaurantplatform/api/controller/auth
[DIR] backend/api/src/main
[DIR] backend/api/src/main/resources
[DIR] backend/api/src/main/resources/db
[DIR] backend/api/src/main/resources/db/migration
[DIR] backend/api/src/main/java
[DIR] backend/api/src/main/java/com
[DIR] backend/api/src/main/java/com/multirestaurantplatform
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/dto
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/dto/error
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/config
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/payload
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/controller
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/controller/auth
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/exception
[DIR] gradle
[DIR] gradle/wrapper
=== .env ===
=== .gitignore ===
# Gradle
.gradle
build/
!build/tmp/checkstyle/ # Example if you want to keep checkstyle reports but ignore rest of build

# IntelliJ IDEA
.idea/
*.iml
*.ipr
*.iws
out/
shelf/ # IntelliJ shelf
workspace.xml # IntelliJ workspace file (often in .idea)

# Spring Boot specific
target/ # Though we use build/, some tools might generate target/

# Maven (in case it's ever used or for consistency)
# target/
# pom.xml.tag
# pom.xml.releaseBackup
# pom.xml.versionsBackup
# release.properties
# dependency-reduced-pom.xml
# buildNumber.properties

# Log files
*.log
logs/

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Environment variables file
.env
*.env
.env.*
!.env.example # Keep example env files if you have them

# Compiled files
*.class
*.jar
*.war
*.ear

# Package Files #
# --------------- #
# *.jar
# *.war
# *.nar
# *.ear
# *.zip
# *.tar.gz
# *.rpm
# *.deb

# Sensitive information
credentials.*
secrets.*

# Local settings
local.properties

# Node / NPM (in case you add frontend directly in the same root later without a separate gitignore)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json # often committed, but sometimes ignored in library projects
yarn.lock # often committed

# VS Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Gradle Wrapper
# We usually commit the wrapper jar but if you choose not to:
# !gradle/wrapper/gradle-wrapper.jar
=== Dockerfile ===
# Stage 1: Build the application using Gradle
FROM gradle:8.7-jdk21 AS build
# The gradle image tag should match a version compatible with your project and JDK.
# Using gradle:8.7-jdk21 since your project uses Java 21 and Gradle 8.x.
# The README.md.pdf also mentioned gradle:8.0-jdk21. Using a slightly newer patch like 8.7 is fine.

WORKDIR /app
# Copy only the files necessary for dependency resolution first to leverage Docker cache
COPY build.gradle settings.gradle /app/
COPY backend/build.gradle /app/backend/
COPY backend/api/build.gradle /app/backend/api/
# If other modules' build.gradle files are needed for resolving api dependencies, copy them too.
# For now, assuming api's dependencies are self-contained or pulled via 'project(...)' correctly.

# Copy the rest of the source code
COPY . /app/
# Grant execution rights to gradlew
RUN chmod +x ./gradlew
# Build the application, targeting the api module's bootJar task
RUN ./gradlew :backend:api:bootJar --no-daemon

# Stage 2: Create the runtime image (This is the part you posted and looks good)
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build /app/backend/api/build/libs/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
=== README.md ===
=== build.gradle ===
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.5' apply false // Define Spring Boot plugin version for all modules
    id 'io.spring.dependency-management' version '1.1.4' // Define & apply dependency management globally
}

// Define common versions in extra properties for easy updates
ext {
    lombokVersion = '1.18.32' // Use a recent, stable Lombok version
    springBootVersion = '3.2.5' // Match the plugin version
    springDocOpenapiVersion = '2.5.0' // Define springdoc version here too
}

allprojects {
    group = 'com.multirestaurantplatform'
    version = '0.0.1-SNAPSHOT'

    repositories {
        mavenCentral()
    }

    // Apply dependency management to ALL projects
    apply plugin: 'io.spring.dependency-management'

    dependencyManagement {
        imports {
            // Import Spring Boot's BOM - this defines versions for Boot dependencies
            mavenBom "org.springframework.boot:spring-boot-dependencies:${springBootVersion}"
        }
        dependencies {
            // Define versions for other direct dependencies we want to manage
            dependency "org.projectlombok:lombok:${lombokVersion}"
            dependency "org.springdoc:springdoc-openapi-starter-webmvc-ui:${springDocOpenapiVersion}"
        }
    }
}

subprojects {
    apply plugin: 'java' // Apply java plugin to all subprojects

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    // Common dependencies for all subprojects
    dependencies {
        // Lombok - version is managed by dependencyManagement
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'
        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'
    }

    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }

    tasks.withType(Test) {
        useJUnitPlatform()
    }
}
=== create_package.sh ===
=== docker-compose.yml ===
version: '3.8'

services:
  multi-restaurant-api:
    build:
      context: .
      dockerfile: Dockerfile
    image: multi-restaurant-platform-backend
    container_name: multi-restaurant-platform
    ports:
      - "8081:8080" # HOST_PORT:CONTAINER_PORT - Access on Mac via 8081, app in container runs on 8080
    environment:
      - SERVER_PORT=8080 # Spring Boot app inside container will listen on port 8080
      # - SPRING_PROFILES_ACTIVE=dev
    restart: unless-stopped
=== gradlew ===
=== gradlew.bat ===
=== scan_project_chatGPT.py ===
=== scan_project_gemini.py ===
=== scan_project_gemini2.py ===
=== settings.gradle ===
// File: settings.gradle
rootProject.name = 'multi-restaurant-platform'

include 'backend'
include 'backend:common'
include 'backend:security'
include 'backend:restaurant'
include 'backend:menu'
include 'backend:order'
include 'backend:payment'
include 'backend:print'
include 'backend:admin'
include 'backend:api'
=== backend/build.gradle ===
// File: multi-restaurant-platform/backend/build.gradle
plugins {
    id 'java'
}

description = 'Parent module for all backend services'

// No specific dependencies or plugins here yet,
// as most will be in the individual microservice modules.
// This file primarily serves as a marker for the 'backend' project
// and can be used for shared configurations among all backend modules later.
=== backend/order/build.gradle ===
// File: multi-restaurant-platform/backend/order/build.gradle
// Replace order with order, security, etc.
plugins {
    id 'java-library' // Use 'java-library' for modules that are intended to be used as libraries by other modules
}

description = 'The order module' // e.g., 'The order module'

dependencies {
    // Module-specific dependencies will be added here later
    // Example:
    // implementation 'org.springframework.boot:spring-boot-starter' // If it needs basic Spring Boot utilities but is not a web app
}
=== backend/restaurant/build.gradle ===
plugins {
    id 'java-library'
}

description = 'The restaurant module'

dependencies {
    // Dependency on the common module (for BaseEntity, etc.)
    implementation project(':backend:common')

    // Dependency on the security module (for User entity)
    implementation project(':backend:security')

    // REMOVED: implementation project(':backend:menu') // This line caused the circular dependency

    // Spring Data JPA (version managed by Spring Boot BOM in root project)
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    implementation 'org.springframework.boot:spring-boot-starter-validation'


    // Lombok is managed in the root build.gradle

    testImplementation 'org.springframework.boot:spring-boot-starter-test' // Includes JUnit 5, Mockito, AssertJ, etc.
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/CreateRestaurantRequestDto.java ===
package com.multirestaurantplatform.restaurant.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CreateRestaurantRequestDto {

    @NotBlank(message = "Restaurant name cannot be blank")
    @Size(min = 2, max = 100, message = "Restaurant name must be between 2 and 100 characters")
    private String name;

    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description;

    @NotBlank(message = "Address cannot be blank")
    @Size(max = 255, message = "Address cannot exceed 255 characters")
    private String address;

    @NotBlank(message = "Phone number cannot be blank")
    @Size(max = 20, message = "Phone number cannot exceed 20 characters")
    private String phoneNumber;

    @Email(message = "Restaurant email should be valid")
    @Size(max = 100, message = "Restaurant email cannot exceed 100 characters")
    private String email; // Contact email for the restaurant

    // We can add fields for initial restaurant admins (e.g., Set<Long> adminUserIds) later if needed.
    // For now, keep it simple. Admin assignment can be a separate operation or part of an update.
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/RestaurantResponseDto.java ===
package com.multirestaurantplatform.restaurant.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;
import java.util.Set; // For future use if we include admin usernames or IDs

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class RestaurantResponseDto {
    private Long id;
    private String name;
    private String description;
    private String address;
    private String phoneNumber;
    private String email;
    private boolean isActive;
    private Instant createdAt;
    private Instant updatedAt;
    // We can add a Set<String> restaurantAdminUsernames later if needed
    // For now, keeping it simple. The controller will map from the Restaurant entity.
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/UpdateRestaurantRequestDto.java ===
// File: backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/UpdateRestaurantRequestDto.java
package com.multirestaurantplatform.restaurant.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set; // Import Set

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UpdateRestaurantRequestDto {

    @Size(min = 2, max = 100, message = "Restaurant name must be between 2 and 100 characters")
    private String name; // Can be null

    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description; // Can be null

    @Size(max = 255, message = "Address cannot exceed 255 characters")
    private String address; // Can be null

    @Size(max = 20, message = "Phone number cannot exceed 20 characters")
    private String phoneNumber; // Can be null

    @Email(message = "Restaurant email should be valid")
    @Size(max = 100, message = "Restaurant email cannot exceed 100 characters")
    private String email; // Can be null

    private Boolean isActive; // Can be null (use Boolean wrapper type)

    // New field to manage restaurant administrators
    // This field is optional. If provided, it will replace the existing set of admins for the restaurant.
    // If null, the admins will not be changed. If an empty set, all admins will be removed.
    private Set<Long> adminUserIds; // Can be null
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/repository/RestaurantRepository.java ===
package com.multirestaurantplatform.restaurant.repository;

import com.multirestaurantplatform.restaurant.model.Restaurant;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RestaurantRepository extends JpaRepository<Restaurant, Long> {

    // Example: Find a restaurant by its exact name (case-sensitive)
    Optional<Restaurant> findByName(String name);

    // Example: Find a restaurant by its email (case-sensitive)
    Optional<Restaurant> findByEmail(String email);

    // You can add more custom query methods here as needed, e.g.:
    // List<Restaurant> findByIsActiveTrue();
    // Page<Restaurant> findByNameContainingIgnoreCase(String name, Pageable pageable);
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/model/Restaurant.java ===
package com.multirestaurantplatform.restaurant.model;

import com.multirestaurantplatform.common.model.BaseEntity;
import com.multirestaurantplatform.security.model.User; // Keep this import
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "restaurants")
public class Restaurant extends BaseEntity {

    @NotBlank(message = "Restaurant name cannot be blank")
    @Size(min = 2, max = 100, message = "Restaurant name must be between 2 and 100 characters")
    @Column(nullable = false, length = 100, unique = true)
    private String name;

    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    @Column(length = 1000)
    private String description;

    @NotBlank(message = "Address cannot be blank")
    @Size(max = 255, message = "Address cannot exceed 255 characters")
    @Column(nullable = false)
    private String address;

    @NotBlank(message = "Phone number cannot be blank")
    @Size(max = 20, message = "Phone number cannot exceed 20 characters")
    @Column(nullable = false, length = 20)
    private String phoneNumber;

    @Email(message = "Restaurant email should be valid")
    @Size(max = 100, message = "Restaurant email cannot exceed 100 characters")
    @Column(length = 100, unique = true)
    private String email;

    @Column(nullable = false)
    private boolean isActive = true;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "restaurant_admins",
            joinColumns = @JoinColumn(name = "restaurant_id"),
            inverseJoinColumns = @JoinColumn(name = "user_id"))
    private Set<User> restaurantAdmins = new HashSet<>();


}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantSecurityService.java ===
package com.multirestaurantplatform.restaurant.service;

public interface RestaurantSecurityService {

    /**
     * Checks if the currently authenticated user (identified by username) is an administrator
     * for the specified restaurant.
     *
     * @param restaurantId The ID of the restaurant to check.
     * @param username The username of the authenticated user.
     * @return true if the user is an administrator for the restaurant, false otherwise.
     */
    boolean isRestaurantAdminForRestaurant(Long restaurantId, String username);
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantSecurityServiceImpl.java ===
package com.multirestaurantplatform.restaurant.service;

import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.repository.RestaurantRepository;
import com.multirestaurantplatform.security.model.Role; // Import Role
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service("restaurantSecurityServiceImpl") // Explicit bean name to match SpEL expression
@RequiredArgsConstructor
public class RestaurantSecurityServiceImpl implements RestaurantSecurityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestaurantSecurityServiceImpl.class);

    private final RestaurantRepository restaurantRepository;
    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true) // Ensures the session is active for lazy loading if needed
    public boolean isRestaurantAdminForRestaurant(Long restaurantId, String username) {
        LOGGER.debug("SecurityCheck: Checking if user '{}' is admin for restaurant ID '{}'", username, restaurantId);

        Optional<User> userOptional = userRepository.findByUsername(username);
        if (userOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: User '{}' not found.", username);
            return false; // User not found, so cannot be an admin
        }
        User user = userOptional.get();

        // Ensure the user actually has the RESTAURANT_ADMIN role.
        // While the @PreAuthorize might check hasRole('RESTAURANT_ADMIN') first,
        // it's good practice for this specific service method to also be mindful of the role
        // or assume the caller (SpEL) has already filtered by role.
        // For robustness, we can add a check here, though SpEL usually handles the role part.
        boolean isRestaurantAdminRole = user.getRoles().stream()
                .anyMatch(role -> role == Role.RESTAURANT_ADMIN);
        if (!isRestaurantAdminRole) {
            LOGGER.debug("SecurityCheck: User '{}' does not have RESTAURANT_ADMIN role.", username);
            // If the SpEL is "(hasRole('RESTAURANT_ADMIN') AND @bean.method())",
            // this check might be redundant but harmless.
            // If SpEL was just "@bean.method()", this check would be critical.
            return false;
        }


        Optional<Restaurant> restaurantOptional = restaurantRepository.findById(restaurantId);
        if (restaurantOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: Restaurant ID '{}' not found.", restaurantId);
            return false; // Restaurant not found
        }
        Restaurant restaurant = restaurantOptional.get();

        // Hibernate will lazy-load restaurant.getRestaurantAdmins() if the session is active.
        // The @Transactional annotation ensures this.
        // We check if the user's ID is present in the set of admin IDs for the restaurant.
        boolean isUserAdminForThisRestaurant = restaurant.getRestaurantAdmins().stream()
                .anyMatch(adminUser -> adminUser.getId().equals(user.getId()));

        if (isUserAdminForThisRestaurant) {
            LOGGER.info("SecurityCheck: User '{}' IS an admin for restaurant ID '{}'. Access granted by this check.", username, restaurantId);
        } else {
            LOGGER.info("SecurityCheck: User '{}' is NOT an admin for restaurant ID '{}'. Access denied by this check.", username, restaurantId);
        }

        return isUserAdminForThisRestaurant;
    }
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantService.java ===
package com.multirestaurantplatform.restaurant.service;

import com.multirestaurantplatform.restaurant.dto.CreateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.dto.UpdateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.model.Restaurant; // Ensure this is the correct model import

import java.util.List;

public interface RestaurantService {

    /**
     * Creates a new restaurant.
     * @param createDto DTO containing data for the new restaurant.
     * @return The created Restaurant entity.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if name or email already exists.
     */
    Restaurant createRestaurant(CreateRestaurantRequestDto createDto);

    /**
     * Finds a restaurant by its ID.
     * @param id The ID of the restaurant.
     * @return The found Restaurant entity.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if restaurant not found.
     */
    Restaurant findRestaurantById(Long id);

    /**
     * Retrieves all restaurants.
     * (Consider adding pagination and filtering in a future iteration)
     * @return A list of all Restaurant entities.
     */
    List<Restaurant> findAllRestaurants();

    /**
     * Updates an existing restaurant.
     * @param id The ID of the restaurant to update.
     * @param updateDto DTO containing data to update.
     * @return The updated Restaurant entity.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if restaurant not found.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if updated name or email conflicts with another restaurant.
     */
    Restaurant updateRestaurant(Long id, UpdateRestaurantRequestDto updateDto);

    /**
     * Deletes a restaurant by its ID.
     * (Consider soft delete by setting isActive=false vs hard delete)
     * @param id The ID of the restaurant to delete.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if restaurant not found.
     */
    void deleteRestaurant(Long id); // For now, a hard delete. Soft delete can be implemented by updating 'isActive'.

    // Future methods could include:
    // Restaurant addAdminToRestaurant(Long restaurantId, Long userId);
    // Restaurant removeAdminFromRestaurant(Long restaurantId, Long userId);
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantServiceImpl.java ===
// File: backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantServiceImpl.java
package com.multirestaurantplatform.restaurant.service;

import com.multirestaurantplatform.common.exception.BadRequestException;
import com.multirestaurantplatform.common.exception.ConflictException;
import com.multirestaurantplatform.common.exception.ResourceNotFoundException;
import com.multirestaurantplatform.restaurant.dto.CreateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.dto.UpdateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.repository.RestaurantRepository;
import com.multirestaurantplatform.security.model.Role; // Import Role
import com.multirestaurantplatform.security.model.User;   // Import User
import com.multirestaurantplatform.security.repository.UserRepository; // Import UserRepository

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor // Lombok for constructor injection
public class RestaurantServiceImpl implements RestaurantService {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestaurantServiceImpl.class);

    private final RestaurantRepository restaurantRepository;
    private final UserRepository userRepository; // Added UserRepository

    @Override
    @Transactional
    public Restaurant createRestaurant(CreateRestaurantRequestDto createDto) {
        LOGGER.info("Attempting to create restaurant with name: {}", createDto.getName());

        restaurantRepository.findByName(createDto.getName()).ifPresent(r -> {
            LOGGER.warn("Restaurant creation failed: name '{}' already exists.", createDto.getName());
            throw new ConflictException("Restaurant with name '" + createDto.getName() + "' already exists.");
        });

        if (StringUtils.hasText(createDto.getEmail())) {
            restaurantRepository.findByEmail(createDto.getEmail()).ifPresent(r -> {
                LOGGER.warn("Restaurant creation failed: email '{}' already exists.", createDto.getEmail());
                throw new ConflictException("Restaurant with email '" + createDto.getEmail() + "' already exists.");
            });
        }

        Restaurant restaurant = new Restaurant();
        restaurant.setName(createDto.getName());
        restaurant.setDescription(createDto.getDescription());
        restaurant.setAddress(createDto.getAddress());
        restaurant.setPhoneNumber(createDto.getPhoneNumber());
        restaurant.setEmail(createDto.getEmail());
        restaurant.setActive(true);
        // Initially, no admins are assigned via create. Admins are set via update.
        restaurant.setRestaurantAdmins(new HashSet<>());

        Restaurant savedRestaurant = restaurantRepository.save(restaurant);
        LOGGER.info("Restaurant created successfully with ID: {}", savedRestaurant.getId());
        return savedRestaurant;
    }

    @Override
    @Transactional(readOnly = true)
    public Restaurant findRestaurantById(Long id) {
        LOGGER.debug("Attempting to find restaurant with ID: {}", id);
        return restaurantRepository.findById(id)
                .orElseThrow(() -> {
                    LOGGER.warn("Restaurant not found with ID: {}", id);
                    return new ResourceNotFoundException("Restaurant not found with ID: " + id);
                });
    }

    @Override
    @Transactional(readOnly = true)
    public List<Restaurant> findAllRestaurants() {
        LOGGER.debug("Fetching all restaurants");
        return restaurantRepository.findAll();
    }

    @Override
    @Transactional
    public Restaurant updateRestaurant(Long id, UpdateRestaurantRequestDto updateDto) {
        LOGGER.info("Attempting to update restaurant with ID: {}", id);
        Restaurant restaurant = findRestaurantById(id); // Throws ResourceNotFoundException if not found

        // Update basic fields
        if (updateDto.getName() != null) {
            String newName = updateDto.getName();
            if (!newName.equals(restaurant.getName())) {
                restaurantRepository.findByName(newName).ifPresent(existing -> {
                    if (!existing.getId().equals(id)) {
                        LOGGER.warn("Restaurant update failed for ID {}: name '{}' already exists for restaurant ID {}.", id, newName, existing.getId());
                        throw new ConflictException("Restaurant with name '" + newName + "' already exists.");
                    }
                });
                restaurant.setName(newName);
            }
        }

        if (updateDto.getEmail() != null) {
            String newEmail = updateDto.getEmail();
            if (StringUtils.hasText(newEmail) && !newEmail.equals(restaurant.getEmail())) {
                restaurantRepository.findByEmail(newEmail).ifPresent(existing -> {
                    if (!existing.getId().equals(id)) {
                        LOGGER.warn("Restaurant update failed for ID {}: email '{}' already exists for restaurant ID {}.", id, newEmail, existing.getId());
                        throw new ConflictException("Restaurant with email '" + newEmail + "' already exists.");
                    }
                });
                restaurant.setEmail(newEmail);
            } else if (updateDto.getEmail().isEmpty() && restaurant.getEmail() != null) {
                restaurant.setEmail(null);
            }
        }

        if (updateDto.getDescription() != null) {
            restaurant.setDescription(updateDto.getDescription());
        }
        if (updateDto.getAddress() != null) {
            restaurant.setAddress(updateDto.getAddress());
        }
        if (updateDto.getPhoneNumber() != null) {
            restaurant.setPhoneNumber(updateDto.getPhoneNumber());
        }
        if (updateDto.getIsActive() != null) {
            restaurant.setActive(updateDto.getIsActive());
        }

        // --- Handle Restaurant Admin Assignment ---
        if (updateDto.getAdminUserIds() != null) {
            LOGGER.info("Updating administrators for restaurant ID: {}. Provided adminUserIds: {}", id, updateDto.getAdminUserIds());
            Set<User> newAdmins = new HashSet<>();
            if (!updateDto.getAdminUserIds().isEmpty()) {
                for (Long adminUserId : updateDto.getAdminUserIds()) {
                    User potentialAdmin = userRepository.findById(adminUserId)
                            .orElseThrow(() -> {
                                LOGGER.warn("User with ID {} not found while assigning admins to restaurant ID {}", adminUserId, id);
                                return new ResourceNotFoundException("User not found with ID: " + adminUserId + " for admin assignment.");
                            });

                    if (!potentialAdmin.getRoles().contains(Role.RESTAURANT_ADMIN)) {
                        LOGGER.warn("User with ID {} (username: {}) does not have RESTAURANT_ADMIN role. Cannot assign as admin to restaurant ID {}",
                                adminUserId, potentialAdmin.getUsername(), id);
                        throw new BadRequestException("User " + potentialAdmin.getUsername() + " (ID: " + adminUserId + ") is not a RESTAURANT_ADMIN and cannot be assigned to manage a restaurant.");
                    }
                    newAdmins.add(potentialAdmin);
                    LOGGER.debug("User {} (ID: {}) added as potential admin for restaurant ID {}", potentialAdmin.getUsername(), adminUserId, id);
                }
            }
            // Replace the existing set of admins with the new set
            restaurant.getRestaurantAdmins().clear(); // Clear existing admins first
            restaurant.getRestaurantAdmins().addAll(newAdmins); // Add new admins
            LOGGER.info("Successfully processed adminUserIds for restaurant ID: {}. New admin count: {}", id, newAdmins.size());
        }
        // If updateDto.getAdminUserIds() is null, the existing admins are not modified.

        Restaurant updatedRestaurant = restaurantRepository.save(restaurant);
        LOGGER.info("Restaurant with ID: {} updated successfully.", id);
        return updatedRestaurant;
    }

    @Override
    @Transactional
    public void deleteRestaurant(Long id) {
        LOGGER.info("Attempting to delete restaurant with ID: {}", id);
        if (!restaurantRepository.existsById(id)) {
            LOGGER.warn("Restaurant deletion failed: not found with ID: {}", id);
            throw new ResourceNotFoundException("Restaurant not found with ID: " + id + " for deletion.");
        }
        // Before deleting a restaurant, consider implications for related entities (e.g., menus, orders).
        // Depending on cascading rules or business logic, you might need to handle these explicitly.
        // For example, disassociating or deleting menus. For now, we assume cascading delete or manual cleanup.
        restaurantRepository.deleteById(id);
        LOGGER.info("Restaurant with ID: {} deleted successfully.", id);
    }
}
=== backend/security/build.gradle ===
// File: multi-restaurant-platform/backend/security/build.gradle
plugins {
    id 'java-library'
}

// Updated description
description = 'The security module handling authentication, authorization, users, roles, JWT, etc.'

// Define jjwt version for consistency
ext {
    jjwtVersion = '0.12.5' // Use a recent stable version of JJWT
}

dependencies {
    // Dependency on the common module (for BaseEntity, etc.)
    implementation project(':backend:common')

    // Spring Boot Security Starter (version managed by BOM in root)
    implementation 'org.springframework.boot:spring-boot-starter-security'

    // Jakarta Bean Validation API
    api 'jakarta.validation:jakarta.validation-api'

    // Spring Boot Validation Starter
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // --- Jakarta Servlet API ---
    // This is needed because classes like JwtAuthenticationFilter and JwtAuthenticationEntryPoint
    // use HttpServletRequest, HttpServletResponse, ServletException, etc.
    // These are not automatically brought in by spring-boot-starter-security for a java-library module.
    // The version will be managed by Spring Boot's dependency management.
    compileOnly 'jakarta.servlet:jakarta.servlet-api'


    // Lombok is inherited from the root build.gradle's subprojects block

    // --- JWT Dependencies ---
    implementation "io.jsonwebtoken:jjwt-api:${jjwtVersion}"
    runtimeOnly "io.jsonwebtoken:jjwt-impl:${jjwtVersion}"
    runtimeOnly "io.jsonwebtoken:jjwt-jackson:${jjwtVersion}"
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/JwtAuthenticationResponse.java ===
package com.multirestaurantplatform.security.dto;

import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor; // Added for Jackson deserialization

/**
 * Represents the response payload containing the JWT access token.
 */
@Getter
@Setter
@NoArgsConstructor // Provides a no-argument constructor, essential for Jackson deserialization
public class JwtAuthenticationResponse {

    private String accessToken;
    private String tokenType = "Bearer"; // Default token type

    /**
     * Constructs a new JwtAuthenticationResponse with the given access token.
     * The tokenType will default to "Bearer".
     *
     * @param accessToken The JWT access token.
     */
    public JwtAuthenticationResponse(String accessToken) {
        this.accessToken = accessToken;
        // tokenType will retain its default "Bearer" or be set by Jackson's setter if present in JSON
    }

    // Optional: If you need a constructor that sets all fields,
    // you could add @AllArgsConstructor from Lombok, or define it manually:
    //
    // import lombok.AllArgsConstructor;
    // @AllArgsConstructor
    //
    // public JwtAuthenticationResponse(String accessToken, String tokenType) {
    //     this.accessToken = accessToken;
    //     this.tokenType = tokenType;
    // }

    // --- Commented out optional fields for user details ---
    // private String username;
    // private java.util.Collection<? extends org.springframework.security.core.GrantedAuthority> authorities;
    //
    // public JwtAuthenticationResponse(String accessToken, String username, java.util.Collection<? extends org.springframework.security.core.GrantedAuthority> authorities) {
    //     this.accessToken = accessToken;
    //     this.username = username;
    //     this.authorities = authorities;
    // }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/LoginRequest.java ===
package com.multirestaurantplatform.security.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data // Lombok: Generates getters, setters, toString, equals, hashCode, and a constructor for all final fields.
public class LoginRequest {

    @NotBlank(message = "Username cannot be blank")
    private String username;

    @NotBlank(message = "Password cannot be blank")
    private String password;

    // No-args constructor (Lombok @Data might provide one, but explicit can be good)
    public LoginRequest() {
    }

    // All-args constructor (Lombok @Data will provide one for final fields, but this is explicit)
    public LoginRequest(String username, String password) {
        this.username = username;
        this.password = password;
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/RegisterRequest.java ===
package com.multirestaurantplatform.security.dto;

import com.multirestaurantplatform.security.model.Role; // Assuming Role enum is in model package
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;
import lombok.Data; // Lombok annotation for boilerplate code (getters, setters, equals, hashCode, toString)

import java.util.Set;

@Data // Bundles @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor
public class RegisterRequest {

    @NotBlank(message = "Username cannot be blank")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @NotBlank(message = "Password cannot be blank")
    @Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters") // Validate length before hashing
    private String password;

    @NotBlank(message = "Email cannot be blank")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email cannot exceed 100 characters")
    private String email;

    @NotEmpty(message = "User must have at least one role")
    private Set<Role> roles; // Specify the roles during registration (e.g., CUSTOMER)
                            // In a real app, you might default this or derive it differently.
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/UserResponseDto.java ===
package com.multirestaurantplatform.security.dto;

import com.multirestaurantplatform.security.model.Role; // Assuming Role is in this package
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserResponseDto {
    private Long id;
    private String username;
    private String email;
    private Set<Role> roles;

    // We can add a static factory method or use a mapping library like MapStruct later
    // for cleaner conversion from User entity to UserResponseDto if needed.
    // For now, manual mapping in the controller/service is fine for simplicity.
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/repository/UserRepository.java ===
package com.multirestaurantplatform.security.repository;

import com.multirestaurantplatform.security.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

/**
 * Spring Data JPA repository for the User entity.
 */
@Repository // Indicates this is a Spring bean and provides exception translation
public interface UserRepository extends JpaRepository<User, Long> { // <EntityType, IdType>

    // --- Spring Data JPA Query Methods ---
    // Implementations are automatically generated based on method names.

    /**
     * Finds a user by their username. Spring Data JPA generates the query.
     * Consider if username search should be case-insensitive based on requirements.
     * @param username The username to search for.
     * @return An Optional containing the found User or empty if not found.
     */
    Optional<User> findByUsername(String username);

    /**
     * Finds a user by their email address. Spring Data JPA generates the query.
     * Consider if email search should be case-insensitive.
     * @param email The email address to search for.
     * @return An Optional containing the found User or empty if not found.
     */
    Optional<User> findByEmail(String email);

    /**
     * Checks if a user exists with the given username.
     * More efficient than findByUsername().isPresent().
     * @param username The username to check.
     * @return true if a user with the username exists, false otherwise.
     */
    boolean existsByUsername(String username);

    /**
     * Checks if a user exists with the given email address.
     * More efficient than findByEmail().isPresent().
     * @param email The email address to check.
     * @return true if a user with the email exists, false otherwise.
     */
    boolean existsByEmail(String email);

    // We can add more complex queries using @Query annotation later if needed.
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/config/JwtAuthenticationEntryPoint.java ===
package com.multirestaurantplatform.security.config; // Or your chosen package for this class

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component // Marks this as a Spring component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationEntryPoint.class);

    /**
     * This method is invoked when an unauthenticated user attempts to access a secured REST resource.
     * It sends an HTTP 401 Unauthorized response.
     *
     * @param request       that resulted in an <code>AuthenticationException</code>
     * @param response      so that the user agent can begin authentication
     * @param authException that caused the invocation
     */
    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException, ServletException {
        // Log the unauthorized attempt for monitoring/debugging purposes
        LOGGER.error("Unauthorized error: {}. Path: {}", authException.getMessage(), request.getRequestURI());

        // Send an HTTP 401 Unauthorized error back to the client
        // You can customize the response further if needed, e.g., by sending a JSON body
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Error: Unauthorized - " + authException.getMessage());
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/config/SecurityConfig.java ===
package com.multirestaurantplatform.security.config;

import com.multirestaurantplatform.security.filter.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer; // Import for frameOptions
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
// import org.springframework.boot.autoconfigure.security.servlet.PathRequest; // Not strictly needed if using specific path matchers

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint unauthorizedHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(unauthorizedHandler)
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(
                                "/api/v1/auth/**",         // Login, Register
                                "/api/v1/test/health",     // Health check path
                                "/swagger-ui.html",
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/webjars/**",
                                "/h2-console/**"          // Permit H2 console access
                        ).permitAll()
                        .anyRequest().authenticated() // All other requests need authentication
                )
                // Configure headers, specifically for X-Frame-Options to allow H2 console
                // This is a common way to allow H2 console frames.
                // Spring Security 6.x new way to configure headers.
                .headers(headers ->
                        headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin // Allow framing from same origin for H2 console
                                // Or, if sameOrigin doesn't work for some reason with H2 console's specific setup:
                                // headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::disable) // Less secure, but might be needed for H2 console
                        )
                );


        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/model/Role.java ===
package com.multirestaurantplatform.security.model;

/**
 * Defines the user roles within the application.
 * Corresponds to authorities in Spring Security.
 */
public enum Role {
    CUSTOMER,        // Regular customer placing orders
    RESTAURANT_ADMIN,// Manages a specific restaurant (menus, orders, settings)
    ADMIN            // Platform administrator (manages restaurants, users, platform settings)
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/model/User.java ===
package com.multirestaurantplatform.security.model;

import com.multirestaurantplatform.common.model.BaseEntity;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor; // Example constructor if needed
import lombok.AllArgsConstructor; // Example constructor if needed

import java.util.Set;

@Getter
@Setter
@NoArgsConstructor // Generates a no-args constructor (required by JPA)
@AllArgsConstructor // Optional: Generates an all-args constructor
@Entity
@Table(name = "users", // Explicitly naming the table "users"
       uniqueConstraints = { // Adding unique constraints at the table level
           @UniqueConstraint(columnNames = "username"),
           @UniqueConstraint(columnNames = "email")
       })
public class User extends BaseEntity {

    @NotBlank // From jakarta.validation.constraints - ensures not null and not just whitespace
    @Size(min = 3, max = 50)
    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @NotBlank
    @Size(min = 8, max = 100) // Store hashed passwords, so length should be sufficient
    @Column(nullable = false, length = 100)
    private String password; // Store hashed passwords ONLY

    @NotBlank
    @Email // Validates if the string is a well-formed email address
    @Size(max = 100)
    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @NotNull // A user must have at least one role
    @Enumerated(EnumType.STRING) // Store the enum name (e.g., "ADMIN") as a string in the DB
    @ElementCollection(fetch = FetchType.EAGER) // Store roles in a separate table (user_roles)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id")) // Customize the join table
    @Column(name = "role", nullable = false) // Column name in the join table
    private Set<Role> roles;

    // Optional: Add other fields like firstName, lastName, phoneNumber, isActive, etc. later
    // private String firstName;
    // private String lastName;
    // private String phoneNumber;
    // private boolean isActive = true; // Default to active

    // Inherits id, createdAt, updatedAt from BaseEntity
    // Inherits equals() and hashCode() from BaseEntity (based on ID)
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/filter/JwtAuthenticationFilter.java ===
package com.multirestaurantplatform.security.filter;

import com.multirestaurantplatform.security.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value; // Ensure this import is present
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationFilter.class);

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Value("${app.jwt.token-prefix}")
    private String tokenPrefix; // Example: "Bearer"

    private static final String AUTHORIZATION_HEADER = "Authorization";

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        LOGGER.debug("JwtAuthenticationFilter: Processing request for URI: {}", request.getRequestURI());
        LOGGER.debug("JwtAuthenticationFilter: Injected tokenPrefix: [{}]", tokenPrefix); // Log the injected prefix

        try {
            final String authHeader = request.getHeader(AUTHORIZATION_HEADER);
            LOGGER.debug("JwtAuthenticationFilter: Authorization Header: [{}]", authHeader);

            if (!StringUtils.hasText(tokenPrefix)) {
                LOGGER.error("JwtAuthenticationFilter: tokenPrefix is not configured or empty! Check 'app.jwt.token-prefix' in properties.");
                filterChain.doFilter(request, response);
                return;
            }

            final String expectedPrefixWithSpace = tokenPrefix + " ";

            if (!StringUtils.hasText(authHeader) || !authHeader.startsWith(expectedPrefixWithSpace)) {
                LOGGER.debug("JwtAuthenticationFilter: JWT Token does not begin with Bearer string or is missing. Header: [{}], Expected Prefix: [{}]", authHeader, expectedPrefixWithSpace);
                filterChain.doFilter(request, response);
                return;
            }

            final String jwt = authHeader.substring(expectedPrefixWithSpace.length());
            LOGGER.debug("JwtAuthenticationFilter: Extracted JWT: [{}]", jwt);

            final String username = jwtService.extractUsername(jwt);
            LOGGER.debug("JwtAuthenticationFilter: Username extracted from JWT: [{}]", username);

            if (StringUtils.hasText(username) && SecurityContextHolder.getContext().getAuthentication() == null) {
                LOGGER.debug("JwtAuthenticationFilter: Username [{}] extracted, SecurityContext is null. Attempting to load UserDetails.", username);
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

                if (userDetails != null) {
                    LOGGER.debug("JwtAuthenticationFilter: UserDetails loaded for username: [{}], Authorities: {}", userDetails.getUsername(), userDetails.getAuthorities());
                    boolean isTokenValid = jwtService.isTokenValid(jwt, userDetails);
                    LOGGER.debug("JwtAuthenticationFilter: Is token valid for username [{}]: {}", username, isTokenValid);

                    if (isTokenValid) {
                        UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                        authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(authToken);
                        LOGGER.info("JwtAuthenticationFilter: Successfully authenticated user [{}] and set SecurityContext.", username);
                    } else {
                        LOGGER.warn("JwtAuthenticationFilter: JWT token validation failed for user: {}", username);
                    }
                } else {
                    LOGGER.warn("JwtAuthenticationFilter: UserDetails not found for username extracted from token: {}", username);
                }
            } else {
                LOGGER.debug("JwtAuthenticationFilter: Username not extracted from JWT or SecurityContext already contains authentication. Username: [{}], Auth: {}", username, SecurityContextHolder.getContext().getAuthentication());
            }
        } catch (Exception e) {
            LOGGER.error("JwtAuthenticationFilter: Cannot set user authentication. Error: {}", e.getMessage(), e);
            // SecurityContextHolder.clearContext(); // Consider if necessary
        }

        filterChain.doFilter(request, response);
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/JwtService.java ===
package com.multirestaurantplatform.security.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {

    private static final Logger LOGGER = LoggerFactory.getLogger(JwtService.class);

    @Value("${app.jwt.secret}")
    private String jwtSecretString;

    @Value("${app.jwt.expiration-ms}")
    private long jwtExpirationMs;

    /**
     * HMAC key derived from {@code jwtSecretString}. The type must be {@link SecretKey}
     * so that the new JJWT 0.12 verify/sign methods resolve without a cast.
     */
    private SecretKey signingKey;

    /**
     * Convert the Base64‑encoded secret string into a {@link SecretKey} once the bean is ready.
     */
    @PostConstruct
    public void init() {
        if (jwtSecretString == null || jwtSecretString.trim().isEmpty()) {
            LOGGER.error("JWT secret key is null or empty – check app.jwt.secret");
            throw new IllegalArgumentException("JWT secret key cannot be null or empty");
        }
        try {
            byte[] keyBytes = Decoders.BASE64.decode(jwtSecretString);
            this.signingKey = Keys.hmacShaKeyFor(keyBytes);
        } catch (Exception ex) {
            LOGGER.error("Invalid Base64 value for app.jwt.secret: {}", ex.getMessage());
            throw new IllegalArgumentException("Invalid JWT secret key", ex);
        }
    }

    /* ---------------------------------------------------------------------
     *  Public API
     * ------------------------------------------------------------------ */

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public <T> T extractClaim(String token, Function<Claims, T> resolver) {
        return resolver.apply(extractAllClaims(token));
    }

    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    /**
     * Build a JWS with optional extra claims using the JJWT 0.12 fluent API
     * (no deprecated setters).
     */
    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {
        long now = System.currentTimeMillis();
        return Jwts.builder()
                .claims()                   // switch into the Claims builder
                .add(extraClaims)       // merge custom claims
                .subject(userDetails.getUsername())
                .issuedAt(new Date(now))
                .expiration(new Date(now + jwtExpirationMs))
                .and()                  // back to the main builder
                .signWith(signingKey, Jwts.SIG.HS256)
                .compact();
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        try {
            return userDetails.getUsername().equals(extractUsername(token)) && !isTokenExpired(token);
        } catch (io.jsonwebtoken.JwtException ex) {
            LOGGER.warn("JWT validation failed for user {}: {}", userDetails.getUsername(), ex.getMessage());
            return false;
        }
    }

    /* ---------------------------------------------------------------------
     *  Private helpers
     * ------------------------------------------------------------------ */

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    /**
     * Parse and verify the supplied compact JWS, returning its {@link Claims} payload.
     */
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(signingKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/UserDetailsServiceImpl.java ===
package com.multirestaurantplatform.security.service;

import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private static final Logger LOGGER = LoggerFactory.getLogger(UserDetailsServiceImpl.class);

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        LOGGER.debug("Attempting to load user by username: {}", username);

        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> {
                    LOGGER.warn("User not found with username: {}", username);
                    return new UsernameNotFoundException("User not found with username: " + username);
                });

        LOGGER.info("User found: {}. Stored hashed password: [PROTECTED]", user.getUsername()); // Don't log the actual hash unless for very specific, temporary debugging.
        // For temporary deep debugging, you could log user.getPassword() but remove it immediately after.
        // LOGGER.debug("Hashed password from DB for user {}: {}", username, user.getPassword());


        Collection<? extends GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> {
                    LOGGER.debug("Mapping role: {} to authority: ROLE_{}", role.name(), role.name());
                    return new SimpleGrantedAuthority("ROLE_" + role.name());
                })
                .collect(Collectors.toSet());

        LOGGER.debug("Authorities for user {}: {}", username, authorities);

        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(), // This is the stored hashed password
                true, // enabled
                true, // accountNonExpired
                true, // credentialsNonExpired
                true, // accountNonLocked
                authorities);
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/UserService.java ===
package com.multirestaurantplatform.security.service;

import com.multirestaurantplatform.common.exception.ResourceNotFoundException; // Import
import com.multirestaurantplatform.security.dto.RegisterRequest;
import com.multirestaurantplatform.security.model.User;

public interface UserService {
    /**
     * Registers a new user based on the provided request data.
     * Handles password encoding and checks for existing username/email.
     *
     * @param registerRequest The user registration data.
     * @return The newly created User entity.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if username or email already exists.
     */
    User registerUser(RegisterRequest registerRequest);

    /**
     * Finds a user by their username.
     *
     * @param username The username to search for.
     * @return The found User entity.
     * @throws ResourceNotFoundException if no user is found with the given username.
     */
    User findUserByUsername(String username);

    /**
     * Finds a user by their ID.
     *
     * @param id The ID of the user to search for.
     * @return The found User entity.
     * @throws ResourceNotFoundException if no user is found with the given ID.
     */
    User findUserById(Long id);

    /**
     * Finds a user by their email address.
     *
     * @param email The email address to search for.
     * @return The found User entity.
     * @throws ResourceNotFoundException if no user is found with the given email.
     */
    User findUserByEmail(String email);

    // Add other methods later, e.g.:
    // User updateUserProfile(Long userId, UpdateProfileRequest request);
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/UserServiceImpl.java ===
package com.multirestaurantplatform.security.service;

import com.multirestaurantplatform.common.exception.ConflictException;
import com.multirestaurantplatform.common.exception.ResourceNotFoundException; // Import
import com.multirestaurantplatform.security.dto.RegisterRequest;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor // Lombok: Creates constructor injecting final fields
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder; // Inject the PasswordEncoder bean

    @Override
    @Transactional // Use transaction for operations involving database writes/reads
    public User registerUser(RegisterRequest request) {
        // 1. Check if username already exists
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new ConflictException("Error: Username '" + request.getUsername() + "' is already taken!");
        }

        // 2. Check if email already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ConflictException("Error: Email '" + request.getEmail() + "' is already in use!");
        }

        // 3. Create new user's account
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setRoles(request.getRoles());

        return userRepository.save(user);
    }

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public User findUserByUsername(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with username: " + username));
    }

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public User findUserById(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + id));
    }

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public User findUserByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with email: " + email));
    }
}
=== backend/payment/build.gradle ===
// File: multi-restaurant-platform/backend/payment/build.gradle
// Replace payment with payment, security, etc.
plugins {
    id 'java-library' // Use 'java-library' for modules that are intended to be used as libraries by other modules
}

description = 'The payment module' // e.g., 'The payment module'

dependencies {
    // Module-specific dependencies will be added here later
    // Example:
    // implementation 'org.springframework.boot:spring-boot-starter' // If it needs basic Spring Boot utilities but is not a web app
}
=== backend/admin/build.gradle ===
// File: multi-restaurant-platform/backend/admin/build.gradle
// Replace admin with admin, security, etc.
plugins {
    id 'java-library' // Use 'java-library' for modules that are intended to be used as libraries by other modules
}

description = 'The admin module' // e.g., 'The admin module'

dependencies {
    // Module-specific dependencies will be added here later
    // Example:
    // implementation 'org.springframework.boot:spring-boot-starter' // If it needs basic Spring Boot utilities but is not a web app
}
=== backend/print/build.gradle ===
// File: multi-restaurant-platform/backend/print/build.gradle
// Replace print with print, security, etc.
plugins {
    id 'java-library' // Use 'java-library' for modules that are intended to be used as libraries by other modules
}

description = 'The print module' // e.g., 'The print module'

dependencies {
    // Module-specific dependencies will be added here later
    // Example:
    // implementation 'org.springframework.boot:spring-boot-starter' // If it needs basic Spring Boot utilities but is not a web app
}
=== backend/common/build.gradle ===
plugins {
    id 'java-library'
}

description = 'The common module containing shared classes like base entities, DTOs, exceptions, etc.'

dependencies {
    // JPA API for annotations like @Entity, @Id, @MappedSuperclass etc.
    // Version managed by Spring Boot BOM imported in root project
    api 'jakarta.persistence:jakarta.persistence-api'

    // Spring Data JPA starter - Version managed by Spring Boot BOM
    api 'org.springframework.boot:spring-boot-starter-data-jpa'

    // Lombok dependencies are now managed in the root build.gradle's subprojects block
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/model/BaseEntity.java ===
package com.multirestaurantplatform.common.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import java.io.Serializable;
import java.time.Instant;
import java.util.Objects;

@Getter
@Setter
@MappedSuperclass // Specifies that this is a base class for entities and its fields should be mapped to the columns of the inheriting entity's table.
public abstract class BaseEntity implements Serializable {

    private static final long serialVersionUID = 1L; // Recommended for Serializable classes

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-incrementing ID strategy suitable for PostgreSQL/H2
    private Long id;

    @CreationTimestamp // Automatically set the timestamp when the entity is first persisted
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @UpdateTimestamp // Automatically update the timestamp when the entity is updated
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    // --- Optional: hashCode() and equals() based on ID ---
    // Useful for JPA entity comparisons, especially within collections.

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BaseEntity that = (BaseEntity) o;
        // Use ID for equality check if it's not null, otherwise rely on object identity
        return id != null && Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        // Use getClass().hashCode() to ensure consistency across different entity types
        return id != null ? Objects.hash(getClass().hashCode(), id) : super.hashCode();
        // Or simply: return getClass().hashCode(); // If ID is sufficient for hash-based collections before persistence
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/AppException.java ===
package com.multirestaurantplatform.common.exception;

public abstract class AppException extends RuntimeException {

    public AppException(String message) {
        super(message);
    }

    public AppException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/BadRequestException.java ===
package com.multirestaurantplatform.common.exception;

public class BadRequestException extends AppException {

    public BadRequestException(String message) {
        super(message);
    }

    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/ConflictException.java ===
package com.multirestaurantplatform.common.exception;

public class ConflictException extends AppException {

    public ConflictException(String message) {
        super(message);
    }

    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/ResourceNotFoundException.java ===
package com.multirestaurantplatform.common.exception;

public class ResourceNotFoundException extends AppException {

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/menu/build.gradle ===
plugins {
    id 'java-library'
}

description = 'The menu module for managing restaurant menus, sections, and items.'

dependencies {
    // Dependency on the common module (for BaseEntity, etc.)
    implementation project(':backend:common')

    // Dependency on the restaurant module (Menu entity has a ManyToOne with Restaurant, MenuSecurityServiceImpl uses RestaurantSecurityService)
    implementation project(':backend:restaurant')

    // ***** ADD THIS LINE *****
    // Dependency on the security module (for User, Role, UserRepository used in MenuSecurityServiceImpl)
    implementation project(':backend:security')
    // *************************

    // Spring Data JPA (version managed by Spring Boot BOM in root project)
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    // Add this for Jakarta Validation API (e.g., @NotBlank, @Size)
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // Lombok is managed in the root build.gradle's subprojects block
    // compileOnly 'org.projectlombok:lombok'
    // annotationProcessor 'org.projectlombok:lombok'

    // --- Test Dependencies ---
    // Spring Boot Test Starter: Includes JUnit 5, Mockito, AssertJ, Spring Test, etc.
    // Version is managed by the Spring Boot BOM imported in the root project.
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    // Lombok for tests (also managed by root build.gradle's subprojects block, but good to be aware)
    // testCompileOnly 'org.projectlombok:lombok'
    // testAnnotationProcessor 'org.projectlombok:lombok'
}

// Ensure JUnit 5 platform is used for tests (usually configured in root build.gradle's subprojects block)
/*
tasks.withType(Test) {
    useJUnitPlatform()
}
*/
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/CreateMenuRequestDto.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/CreateMenuRequestDto.java
package com.multirestaurantplatform.menu.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CreateMenuRequestDto {

    @NotBlank(message = "Menu name cannot be blank")
    @Size(min = 2, max = 100, message = "Menu name must be between 2 and 100 characters")
    private String name;

    @Size(max = 500, message = "Description cannot exceed 500 characters") // Optional field
    private String description;

    @NotNull(message = "Restaurant ID cannot be null")
    private Long restaurantId;
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/MenuResponseDto.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/MenuResponseDto.java
        package com.multirestaurantplatform.menu.dto;

import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.Instant;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class MenuResponseDto {

    private Long id;
    private String name;
    private String description;
    private boolean isActive;
    private Long restaurantId; // To show which restaurant this menu belongs to
    private Instant createdAt;
    private Instant updatedAt;
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/UpdateMenuRequestDto.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/UpdateMenuRequestDto.java
package com.multirestaurantplatform.menu.dto;

import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UpdateMenuRequestDto {

    @Size(min = 2, max = 100, message = "Menu name must be between 2 and 100 characters")
    private String name; // Optional: if null, not updated

    @Size(max = 500, message = "Description cannot exceed 500 characters")
    private String description; // Optional: if null, not updated

    private Boolean isActive; // Optional: if null, not updated
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/repository/MenuRepository.java ===
package com.multirestaurantplatform.menu.repository;

import com.multirestaurantplatform.menu.model.Menu;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface MenuRepository extends JpaRepository<Menu, Long> {

    // Find all menus for a specific restaurant
    List<Menu> findByRestaurantId(Long restaurantId);

    // Find all active menus for a specific restaurant
    List<Menu> findByRestaurantIdAndIsActiveTrue(Long restaurantId);

    // Find a menu by its name and restaurant ID (to check for duplicates within a restaurant)
    Optional<Menu> findByRestaurantIdAndNameIgnoreCase(Long restaurantId, String name);

    // You can add more custom query methods here as needed.
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/model/Menu.java ===
package com.multirestaurantplatform.menu.model;

import com.multirestaurantplatform.common.model.BaseEntity;
import com.multirestaurantplatform.restaurant.model.Restaurant; // Import Restaurant
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "menus", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"restaurant_id", "name"}, name = "uq_menus_restaurant_id_name")
})
public class Menu extends BaseEntity {

    @NotBlank(message = "Menu name cannot be blank")
    @Size(min = 2, max = 100, message = "Menu name must be between 2 and 100 characters")
    @Column(nullable = false, length = 100)
    private String name;

    @Size(max = 500, message = "Description cannot exceed 500 characters")
    @Column(length = 500)
    private String description;

    @Column(nullable = false)
    private boolean isActive = true;

    @NotNull(message = "Menu must be associated with a restaurant")
    @ManyToOne(fetch = FetchType.LAZY) // Many menus can belong to one restaurant
    @JoinColumn(name = "restaurant_id", nullable = false) // Foreign key column in the 'menus' table
    private Restaurant restaurant;

    // toString, equals, and hashCode are inherited from BaseEntity (or can be customized if needed)
    // We might add @OneToMany for MenuSection later
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityService.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityService.java
package com.multirestaurantplatform.menu.service;

public interface MenuSecurityService {

    /**
     * Checks if the currently authenticated user (identified by username) has permission
     * to manage the specified menu.
     * This is typically used by RESTAURANT_ADMIN to ensure they only manage menus
     * belonging to restaurants they administer.
     *
     * @param menuId The ID of the menu to check.
     * @param username The username of the authenticated user (typically from `principal.username`).
     * @return true if the user is authorized to manage the menu, false otherwise.
     */
    boolean canManageMenu(Long menuId, String username);
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityServiceImpl.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityServiceImpl.java
package com.multirestaurantplatform.menu.service;

import com.multirestaurantplatform.menu.model.Menu;
import com.multirestaurantplatform.menu.repository.MenuRepository;
import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.service.RestaurantSecurityService; // Assuming this is the correct interface
import com.multirestaurantplatform.security.model.Role;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service("menuSecurityServiceImpl") // Explicit bean name for SpEL expression in @PreAuthorize
@RequiredArgsConstructor
public class MenuSecurityServiceImpl implements MenuSecurityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(MenuSecurityServiceImpl.class);

    private final MenuRepository menuRepository;
    private final UserRepository userRepository; // To fetch user roles
    private final RestaurantSecurityService restaurantSecurityService; // To check if user is admin for the restaurant

    @Override
    @Transactional(readOnly = true) // Read-only as it's a check operation
    public boolean canManageMenu(Long menuId, String username) {
        LOGGER.debug("SecurityCheck: Checking if user '{}' can manage menu ID '{}'", username, menuId);

        // 1. Fetch the user to check their roles
        Optional<User> userOptional = userRepository.findByUsername(username);
        if (userOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: User '{}' not found. Cannot manage menu.", username);
            return false;
        }
        User user = userOptional.get();

        // 2. Ensure the user has the RESTAURANT_ADMIN role.
        //    While @PreAuthorize("hasRole('RESTAURANT_ADMIN') and @bean.method()") handles the role check,
        //    it's good for this service to be aware or for standalone use.
        boolean isRestaurantAdminRole = user.getRoles().stream()
                .anyMatch(role -> role == Role.RESTAURANT_ADMIN);

        if (!isRestaurantAdminRole) {
            LOGGER.debug("SecurityCheck: User '{}' does not have RESTAURANT_ADMIN role. Cannot manage menu.", username);
            return false; // If not a RESTAURANT_ADMIN, they can't manage via this specific check.
                          // ADMIN role would be handled by a separate "hasRole('ADMIN')" in @PreAuthorize.
        }

        // 3. Fetch the menu
        Optional<Menu> menuOptional = menuRepository.findById(menuId);
        if (menuOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: Menu ID '{}' not found. Cannot determine management permission.", menuId);
            // If menu doesn't exist, access is implicitly denied for management.
            // The controller will likely throw a 404 separately.
            return false;
        }
        Menu menu = menuOptional.get();

        // 4. Get the restaurant associated with the menu
        Restaurant restaurant = menu.getRestaurant();
        if (restaurant == null) {
            LOGGER.error("SecurityCheck: Menu ID '{}' is not associated with any restaurant. Data integrity issue?", menuId);
            return false; // Should not happen in a consistent DB state
        }
        Long restaurantId = restaurant.getId();

        // 5. Delegate to RestaurantSecurityService to check if the user is an admin for this specific restaurant
        boolean isUserAdminForRestaurant = restaurantSecurityService.isRestaurantAdminForRestaurant(restaurantId, username);

        if (isUserAdminForRestaurant) {
            LOGGER.info("SecurityCheck: User '{}' IS an admin for restaurant ID '{}' (owner of menu ID '{}'). Access GRANTED by this check.", username, restaurantId, menuId);
        } else {
            LOGGER.info("SecurityCheck: User '{}' is NOT an admin for restaurant ID '{}' (owner of menu ID '{}'). Access DENIED by this check.", username, restaurantId, menuId);
        }

        return isUserAdminForRestaurant;
    }
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuService.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuService.java
package com.multirestaurantplatform.menu.service;

import com.multirestaurantplatform.menu.dto.CreateMenuRequestDto;
import com.multirestaurantplatform.menu.dto.MenuResponseDto;
import com.multirestaurantplatform.menu.dto.UpdateMenuRequestDto;

import java.util.List;

public interface MenuService {

    /**
     * Creates a new menu for a given restaurant.
     *
     * @param createMenuRequestDto DTO containing details for the new menu, including restaurantId.
     * @return MenuResponseDto of the created menu.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the specified restaurant does not exist.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if a menu with the same name already exists for the restaurant.
     */
    MenuResponseDto createMenu(CreateMenuRequestDto createMenuRequestDto);

    /**
     * Finds a menu by its unique ID.
     *
     * @param menuId The ID of the menu to find.
     * @return MenuResponseDto of the found menu.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the menu with the given ID is not found.
     */
    MenuResponseDto findMenuById(Long menuId);

    /**
     * Finds all menus associated with a specific restaurant ID.
     *
     * @param restaurantId The ID of the restaurant.
     * @return A list of MenuResponseDto for the specified restaurant.
     * Returns an empty list if the restaurant has no menus or does not exist (though ideally, check restaurant existence separately if needed).
     */
    List<MenuResponseDto> findMenusByRestaurantId(Long restaurantId);

    /**
     * Finds all active menus associated with a specific restaurant ID.
     *
     * @param restaurantId The ID of the restaurant.
     * @return A list of active MenuResponseDto for the specified restaurant.
     * Returns an empty list if the restaurant has no active menus.
     */
    List<MenuResponseDto> findActiveMenusByRestaurantId(Long restaurantId);

    /**
     * Updates an existing menu.
     *
     * @param menuId The ID of the menu to update.
     * @param updateMenuRequestDto DTO containing the fields to update. Null fields in DTO are ignored.
     * @return MenuResponseDto of the updated menu.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the menu with the given ID is not found.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if updating the name causes a conflict with another menu in the same restaurant.
     */
    MenuResponseDto updateMenu(Long menuId, UpdateMenuRequestDto updateMenuRequestDto);

    /**
     * Deletes a menu by its ID.
     * This could be a hard delete or a soft delete (setting isActive to false).
     * The implementation will define the exact behavior.
     *
     * @param menuId The ID of the menu to delete.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the menu with the given ID is not found (for hard delete scenarios).
     */
    void deleteMenu(Long menuId);
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuServiceImpl.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuServiceImpl.java
package com.multirestaurantplatform.menu.service;

import com.multirestaurantplatform.common.exception.ConflictException;
import com.multirestaurantplatform.common.exception.ResourceNotFoundException;
import com.multirestaurantplatform.menu.dto.CreateMenuRequestDto;
import com.multirestaurantplatform.menu.dto.MenuResponseDto;
import com.multirestaurantplatform.menu.dto.UpdateMenuRequestDto;
import com.multirestaurantplatform.menu.model.Menu;
import com.multirestaurantplatform.menu.repository.MenuRepository;
import com.multirestaurantplatform.restaurant.model.Restaurant; // Assuming this is the correct model
import com.multirestaurantplatform.restaurant.repository.RestaurantRepository; // Assuming this is the correct repository

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class MenuServiceImpl implements MenuService {

    private static final Logger LOGGER = LoggerFactory.getLogger(MenuServiceImpl.class);

    private final MenuRepository menuRepository;
    private final RestaurantRepository restaurantRepository; // To validate restaurantId

    /**
     * Helper method to find a Menu entity by its ID or throw ResourceNotFoundException.
     * @param menuId The ID of the menu.
     * @return The found Menu entity.
     */
    private Menu findMenuEntityById(Long menuId) {
        return menuRepository.findById(menuId)
                .orElseThrow(() -> {
                    LOGGER.warn("Menu not found with ID: {}", menuId);
                    return new ResourceNotFoundException("Menu not found with ID: " + menuId);
                });
    }

    /**
     * Helper method to map a Menu entity to a MenuResponseDto.
     * @param menu The Menu entity.
     * @return The corresponding MenuResponseDto.
     */
    private MenuResponseDto mapToMenuResponseDto(Menu menu) {
        if (menu == null) {
            return null;
        }
        return new MenuResponseDto(
                menu.getId(),
                menu.getName(),
                menu.getDescription(),
                menu.isActive(),
                menu.getRestaurant() != null ? menu.getRestaurant().getId() : null, // Handle potential null restaurant
                menu.getCreatedAt(),
                menu.getUpdatedAt()
        );
    }

    @Override
    @Transactional
    public MenuResponseDto createMenu(CreateMenuRequestDto createMenuRequestDto) {
        LOGGER.info("Attempting to create menu with name: {} for restaurant ID: {}", createMenuRequestDto.getName(), createMenuRequestDto.getRestaurantId());

        // Validate that the restaurantId from the DTO corresponds to an existing Restaurant
        Restaurant restaurant = restaurantRepository.findById(createMenuRequestDto.getRestaurantId())
                .orElseThrow(() -> {
                    LOGGER.warn("Restaurant not found with ID: {} during menu creation", createMenuRequestDto.getRestaurantId());
                    return new ResourceNotFoundException("Restaurant not found with ID: " + createMenuRequestDto.getRestaurantId() + " while creating menu.");
                });

        // Check if a menu with the same name already exists for the given restaurant
        menuRepository.findByRestaurantIdAndNameIgnoreCase(createMenuRequestDto.getRestaurantId(), createMenuRequestDto.getName())
                .ifPresent(existingMenu -> {
                    LOGGER.warn("Menu creation failed: name '{}' already exists for restaurant ID {}.", createMenuRequestDto.getName(), createMenuRequestDto.getRestaurantId());
                    throw new ConflictException("Menu with name '" + createMenuRequestDto.getName() + "' already exists for this restaurant.");
                });

        Menu menu = new Menu();
        menu.setName(createMenuRequestDto.getName());
        menu.setDescription(createMenuRequestDto.getDescription());
        menu.setRestaurant(restaurant);
        menu.setActive(true); // Default to active

        Menu savedMenu = menuRepository.save(menu);
        LOGGER.info("Menu created successfully with ID: {}", savedMenu.getId());
        return mapToMenuResponseDto(savedMenu);
    }

    @Override
    @Transactional(readOnly = true)
    public MenuResponseDto findMenuById(Long menuId) {
        LOGGER.debug("Attempting to find menu with ID: {}", menuId);
        Menu menu = findMenuEntityById(menuId);
        return mapToMenuResponseDto(menu);
    }

    @Override
    @Transactional(readOnly = true)
    public List<MenuResponseDto> findMenusByRestaurantId(Long restaurantId) {
        LOGGER.debug("Fetching all menus for restaurant ID: {}", restaurantId);
        // Optional: Check if restaurant exists first if strict validation is needed before querying menus
        // if (!restaurantRepository.existsById(restaurantId)) {
        //     LOGGER.warn("Attempted to fetch menus for non-existent restaurant ID: {}", restaurantId);
        //     return Collections.emptyList(); // Or throw ResourceNotFoundException
        // }
        List<Menu> menus = menuRepository.findByRestaurantId(restaurantId);
        return menus.stream()
                .map(this::mapToMenuResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<MenuResponseDto> findActiveMenusByRestaurantId(Long restaurantId) {
        LOGGER.debug("Fetching active menus for restaurant ID: {}", restaurantId);
        List<Menu> activeMenus = menuRepository.findByRestaurantIdAndIsActiveTrue(restaurantId);
        return activeMenus.stream()
                .map(this::mapToMenuResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public MenuResponseDto updateMenu(Long menuId, UpdateMenuRequestDto updateMenuRequestDto) {
        LOGGER.info("Attempting to update menu with ID: {}", menuId);
        Menu menu = findMenuEntityById(menuId);

        // If name is being updated, check for name conflicts within the same restaurant
        if (StringUtils.hasText(updateMenuRequestDto.getName()) && !updateMenuRequestDto.getName().equalsIgnoreCase(menu.getName())) {
            menuRepository.findByRestaurantIdAndNameIgnoreCase(menu.getRestaurant().getId(), updateMenuRequestDto.getName())
                    .ifPresent(existingMenu -> {
                        if (!existingMenu.getId().equals(menuId)) { // Ensure it's not the same menu
                            LOGGER.warn("Menu update failed for ID {}: name '{}' already exists for restaurant ID {}.", menuId, updateMenuRequestDto.getName(), menu.getRestaurant().getId());
                            throw new ConflictException("Another menu with name '" + updateMenuRequestDto.getName() + "' already exists for this restaurant.");
                        }
                    });
            menu.setName(updateMenuRequestDto.getName());
        }

        if (updateMenuRequestDto.getDescription() != null) {
            menu.setDescription(updateMenuRequestDto.getDescription());
        }

        if (updateMenuRequestDto.getIsActive() != null) {
            menu.setActive(updateMenuRequestDto.getIsActive());
        }

        Menu updatedMenu = menuRepository.save(menu);
        LOGGER.info("Menu with ID: {} updated successfully.", updatedMenu.getId());
        return mapToMenuResponseDto(updatedMenu);
    }

    @Override
    @Transactional
    public void deleteMenu(Long menuId) {
        LOGGER.info("Attempting to soft delete menu with ID: {}", menuId);
        Menu menu = findMenuEntityById(menuId);

        if (!menu.isActive()) {
            LOGGER.info("Menu with ID: {} is already inactive.", menuId);
            // Optionally, you could throw an exception or just do nothing.
            // For now, we'll just log and proceed (idempotency for deactivation).
        }

        menu.setActive(false);
        menuRepository.save(menu);
        LOGGER.info("Menu with ID: {} soft deleted (set to inactive) successfully.", menuId);
        // For hard delete, it would be:
        // if (!menuRepository.existsById(menuId)) {
        //     throw new ResourceNotFoundException("Menu not found with ID: " + menuId + " for deletion.");
        // }
        // menuRepository.deleteById(menuId);
        // LOGGER.info("Menu with ID: {} hard deleted successfully.", menuId);
    }
}
=== backend/api/build.gradle ===
// File: multi-restaurant-platform/backend/api/build.gradle
plugins {
    id 'java' // Standard Java plugin
    id 'org.springframework.boot' // Apply Spring Boot plugin
}

description = 'The main API application module (Spring Boot)'

// Dependency Management is applied via allprojects in root build.gradle

dependencies {
    // --- Spring Boot Starters (Versions managed by BOM in root project) ---
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa' // Ensure JPA auto-config runs
    implementation 'org.springframework.boot:spring-boot-starter-validation'// For validation features
    implementation 'org.springframework.boot:spring-boot-starter-security' // Ensure Security auto-config runs

    // --- Database & Migration ---
    // H2 Database (Runtime only for local development/testing)
    runtimeOnly 'com.h2database:h2'
    // Flyway for Database Migrations (Version managed by BOM in root project)
    implementation 'org.flywaydb:flyway-core'

    // --- API Documentation (Version managed by dependencyManagement in root project) ---
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui'

    // --- Environment Variable Management ---
    // Library to load .env files. This allows us to use a .env file for local configuration.
    implementation 'io.github.cdimascio:dotenv-java:2.3.2' // Using version 2.3.2, ensure this is a recent stable version.

    // --- Local Module Dependencies ---
    implementation project(':backend:common')
    implementation project(':backend:security')
    implementation project(':backend:admin')
    // Add other modules as they become relevant and needed by the api module
    implementation project(':backend:restaurant')
    implementation project(':backend:menu')
    // implementation project(':backend:order')
    // implementation project(':backend:payment')
    // implementation project(':backend:print')

    // --- Testing (Version managed by BOM in root project) ---
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test' // For @WithMockUser etc.


    // Lombok dependencies are managed in the root build.gradle
}

springBoot {
    mainClass = 'com.multirestaurantplatform.api.ApiApplication' // Verify this is your correct main class path
}

// If you plan to build executable JARs (default for Spring Boot)
bootJar {
    layered {
        enabled = true // Optimizes Docker image layering
    }
}
=== backend/api/src/main/resources/application.properties ===
# File: multi-restaurant-platform/backend/api/src/main/resources/application.properties

# Default Server Configuration
server.port=8081

# Application Name
spring.application.name=multi-restaurant-platform-backend

# --- H2 Database Console Settings (for development) ---
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# --- JPA / Hibernate Settings ---
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
# How Hibernate interacts with the schema. Set to 'validate' or 'none' when using Flyway.
# 'validate': Checks if the DB schema matches JPA entities on startup (good for catching mismatches).
# 'none': Trusts Flyway completely to manage the schema.
# Avoid 'create', 'create-drop', or 'update' when Flyway is active.
spring.jpa.hibernate.ddl-auto=validate
# --- Flyway Settings ---
spring.flyway.enabled=true
# spring.flyway.locations=classpath:db/migration # Default location

# --- SpringDoc OpenAPI (Swagger UI) Configuration ---
# springdoc.swagger-ui.path=/swagger-ui.html
# springdoc.api-docs.path=/v3/api-docs

# --- JWT Configuration ---
# The JWT secret key is read from the JWT_SECRET_KEY environment variable.
# This variable is loaded from the .env file by dotenv-java during local development.
app.jwt.secret=${JWT_SECRET_KEY:fallback-secret-for-testing-only-if-env-is-missing-replace-or-remove-for-prod}

# Token validity duration in milliseconds. Example: 1 hour = 3600000 ms.
app.jwt.expiration-ms=3600000

# Standard prefix for the JWT in the Authorization header (e.g., "Bearer <token>"). Note the space at the end.
app.jwt.token-prefix=Bearer

# --- Logging Configuration ---
logging.level.com.multirestaurantplatform.security=DEBUG
=== backend/api/src/main/resources/db/migration/V1__Initial_Schema.sql ===
=== backend/api/src/main/resources/db/migration/V2__Create_Restaurant_Tables.sql ===
=== backend/api/src/main/resources/db/migration/V3__Create_Menu_Table.sql ===
=== backend/api/src/main/java/com/multirestaurantplatform/api/ApiApplication.java ===
package com.multirestaurantplatform.api;

import io.github.cdimascio.dotenv.Dotenv;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication(scanBasePackages = "com.multirestaurantplatform")
@EnableJpaRepositories(basePackages = {
        "com.multirestaurantplatform.security.repository",
        "com.multirestaurantplatform.restaurant.repository",
        "com.multirestaurantplatform.menu.repository" // Add this line
})
@EntityScan(basePackages = {
        "com.multirestaurantplatform.security.model",
        "com.multirestaurantplatform.common.model",
        "com.multirestaurantplatform.restaurant.model",
        "com.multirestaurantplatform.menu.model" // Add this line
})
public class ApiApplication {

    public static void main(String[] args) {
        Dotenv dotenv = Dotenv.configure()
                .directory("../../") // Path from backend/api to project root
                .filename(".env")    // Explicitly specify the filename
                .ignoreIfMissing()   // Don't throw an error if .env is not found
                .ignoreIfMalformed() // Don't throw an error if .env is malformed
                .load();

        String loadedSecret = dotenv.get("JWT_SECRET_KEY");
        if (loadedSecret != null && !loadedSecret.trim().isEmpty()) {
            System.setProperty("JWT_SECRET_KEY", loadedSecret);
        }
        SpringApplication.run(ApiApplication.class, args);
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/dto/error/ErrorResponse.java ===
package com.multirestaurantplatform.api.dto.error;

import java.time.LocalDateTime;

public record ErrorResponse(
    LocalDateTime timestamp,
    int status,
    String error, // Short error description e.g., "Not Found", "Bad Request"
    String message, // Detailed error message from the exception
    String path // The request path
) {
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/config/OpenApiConfig.java ===
package com.multirestaurantplatform.api.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Collections; // Import Collections

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        final String securitySchemeName = "bearerAuth"; // Define the security scheme name

        return new OpenAPI()
                .info(new Info()
                        .title("Multi-Restaurant Platform API")
                        .version("1.0")
                        .description("API documentation for the Multi-Restaurant Platform Backend"))
                .addSecurityItem(new SecurityRequirement().addList(securitySchemeName, Collections.emptyList())) // Use addList with empty scopes
                .components(new Components()
                        .addSecuritySchemes(securitySchemeName, new SecurityScheme() // Use the defined name
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")
                                .description("Enter JWT token in the format 'Bearer <token>'")
                        ));
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/HealthCheckController.java ===
package com.multirestaurantplatform.api.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize; // For method-level security
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/test") // Changed base path for clarity, or keep /health and add new mapping
public class HealthCheckController { // Renaming to TestController might be better if adding more test endpoints

    @GetMapping("/health") // This remains public as per SecurityConfig
    public Map<String, String> checkHealth() {
        return Collections.singletonMap("status", "UP");
    }

    // New SECURED endpoint
    @GetMapping("/secure-data")
    // @PreAuthorize("isAuthenticated()") // Alternative: method-level security if @EnableMethodSecurity is on SecurityConfig
    public ResponseEntity<Map<String, Object>> getSecureData() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = "anonymous";

        if (authentication != null && authentication.getPrincipal() instanceof UserDetails) {
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            username = userDetails.getUsername();
        } else if (authentication != null) {
            username = authentication.getName();
        }

        Map<String, Object> data = new HashMap<>();
        data.put("message", "This is secured data for authenticated users.");
        data.put("user", username);
        data.put("authorities", authentication != null ? authentication.getAuthorities() : Collections.emptyList());

        return ResponseEntity.ok(data);
    }

    // Example of an admin-only endpoint (requires @EnableMethodSecurity in SecurityConfig)
    @GetMapping("/admin-only")
    @PreAuthorize("hasRole('ADMIN')") // Ensure your roles are prefixed with ROLE_ in UserDetails authorities, or use hasAuthority('ADMIN')
    public ResponseEntity<String> getAdminData() {
        return ResponseEntity.ok("This is data only for users with the ADMIN role.");
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/MenuController.java ===
// File: backend/api/src/main/java/com/multirestaurantplatform/api/controller/MenuController.java
package com.multirestaurantplatform.api.controller;

import com.multirestaurantplatform.menu.dto.CreateMenuRequestDto;
import com.multirestaurantplatform.menu.dto.MenuResponseDto;
import com.multirestaurantplatform.menu.dto.UpdateMenuRequestDto;
import com.multirestaurantplatform.menu.service.MenuService;
// Import MenuSecurityService if you need to inject its bean, though for SpEL it's usually not directly injected here
// import com.multirestaurantplatform.menu.service.MenuSecurityService;
// Import RestaurantSecurityService if you need to inject its bean for SpEL usage
// import com.multirestaurantplatform.restaurant.service.RestaurantSecurityService;


import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/menus")
@RequiredArgsConstructor
@Tag(name = "Menu Management", description = "APIs for managing restaurant menus")
@SecurityRequirement(name = "bearerAuth") // Indicates JWT is generally required
public class MenuController {

    private static final Logger LOGGER = LoggerFactory.getLogger(MenuController.class);
    private final MenuService menuService;
    // No need to inject security services here if they are only used in @PreAuthorize SpEL expressions
    // and are correctly named Spring beans (e.g., @Service("menuSecurityServiceImpl"))

    @PostMapping
    // This PreAuthorize assumes restaurantSecurityServiceImpl is a bean named "restaurantSecurityServiceImpl"
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @restaurantSecurityServiceImpl.isRestaurantAdminForRestaurant(#createMenuRequestDto.restaurantId, principal.username))")
    @Operation(summary = "Create a new menu",
            description = "Creates a new menu for a specified restaurant. Requires ADMIN role or RESTAURANT_ADMIN role for the target restaurant.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Menu created successfully",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Invalid input data",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized - JWT token is missing or invalid",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "403", description = "Forbidden - User does not have necessary permissions",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Restaurant not found",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "409", description = "Conflict - Menu name already exists for the restaurant",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<MenuResponseDto> createMenu(
            @Valid @RequestBody CreateMenuRequestDto createMenuRequestDto) {
        LOGGER.info("API call to create menu: {} for restaurant ID: {}", createMenuRequestDto.getName(), createMenuRequestDto.getRestaurantId());
        MenuResponseDto createdMenu = menuService.createMenu(createMenuRequestDto);
        LOGGER.info("Menu created with ID: {}", createdMenu.getId());
        return new ResponseEntity<>(createdMenu, HttpStatus.CREATED);
    }

    @GetMapping("/{menuId}")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get a menu by ID",
            description = "Retrieves details of a specific menu by its ID. Accessible by any authenticated user.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Menu found",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Menu not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<MenuResponseDto> getMenuById(
            @Parameter(description = "ID of the menu to be retrieved") @PathVariable Long menuId) {
        LOGGER.debug("API call to get menu by ID: {}", menuId);
        MenuResponseDto menu = menuService.findMenuById(menuId);
        return ResponseEntity.ok(menu);
    }

    @GetMapping("/by-restaurant/{restaurantId}")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get all menus for a restaurant",
            description = "Retrieves a list of all menus for a specific restaurant. Accessible by any authenticated user.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "List of menus retrieved",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))), // Assuming list response
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
            })
    public ResponseEntity<List<MenuResponseDto>> getMenusByRestaurantId(
            @Parameter(description = "ID of the restaurant whose menus are to be retrieved") @PathVariable Long restaurantId) {
        LOGGER.debug("API call to get all menus for restaurant ID: {}", restaurantId);
        List<MenuResponseDto> menus = menuService.findMenusByRestaurantId(restaurantId);
        return ResponseEntity.ok(menus);
    }

    @GetMapping("/by-restaurant/{restaurantId}/active")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get active menus for a restaurant",
            description = "Retrieves a list of active menus for a specific restaurant. Accessible by any authenticated user.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "List of active menus retrieved",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
            })
    public ResponseEntity<List<MenuResponseDto>> getActiveMenusByRestaurantId(
            @Parameter(description = "ID of the restaurant whose active menus are to be retrieved") @PathVariable Long restaurantId) {
        LOGGER.debug("API call to get active menus for restaurant ID: {}", restaurantId);
        List<MenuResponseDto> activeMenus = menuService.findActiveMenusByRestaurantId(restaurantId);
        return ResponseEntity.ok(activeMenus);
    }

    @PutMapping("/{menuId}")
    // Updated PreAuthorize to use menuSecurityServiceImpl
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @menuSecurityServiceImpl.canManageMenu(#menuId, principal.username))")
    @Operation(summary = "Update an existing menu",
            description = "Updates details of an existing menu. Requires ADMIN role, or RESTAURANT_ADMIN role for the restaurant owning the menu.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Menu updated successfully",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Invalid input data", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Menu not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "409", description = "Conflict - Updated name already exists for the restaurant", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<MenuResponseDto> updateMenu(
            @Parameter(description = "ID of the menu to be updated") @PathVariable Long menuId,
            @Valid @RequestBody UpdateMenuRequestDto updateMenuRequestDto) {
        LOGGER.info("API call to update menu with ID: {}", menuId);
        MenuResponseDto updatedMenu = menuService.updateMenu(menuId, updateMenuRequestDto);
        LOGGER.info("Menu with ID: {} updated successfully", updatedMenu.getId());
        return ResponseEntity.ok(updatedMenu);
    }

    @DeleteMapping("/{menuId}")
    // Updated PreAuthorize to use menuSecurityServiceImpl
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @menuSecurityServiceImpl.canManageMenu(#menuId, principal.username))")
    @Operation(summary = "Delete a menu by ID (Soft Delete)",
            description = "Soft deletes a menu by its ID (sets isActive to false). Requires ADMIN role, or RESTAURANT_ADMIN role for the restaurant owning the menu.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Menu deleted successfully (set to inactive)"),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Menu not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<Void> deleteMenu(
            @Parameter(description = "ID of the menu to be deleted") @PathVariable Long menuId) {
        LOGGER.info("API call to delete menu with ID: {}", menuId);
        menuService.deleteMenu(menuId);
        LOGGER.info("Menu with ID: {} soft deleted successfully", menuId);
        return ResponseEntity.noContent().build();
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/RestaurantController.java ===
package com.multirestaurantplatform.api.controller;

import com.multirestaurantplatform.restaurant.dto.CreateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.dto.RestaurantResponseDto;
import com.multirestaurantplatform.restaurant.dto.UpdateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.service.RestaurantService;
// Import your custom security service if you create one for method-level checks
// import com.multirestaurantplatform.security.service.RestaurantSecurityService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/restaurants")
@RequiredArgsConstructor
@Tag(name = "Restaurant Management", description = "APIs for managing restaurants")
@SecurityRequirement(name = "bearerAuth") // Indicates that JWT is required for these endpoints by default
public class RestaurantController {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestaurantController.class);
    private final RestaurantService restaurantService;
    // Uncomment if you implement RestaurantSecurityService for custom authorization
    // private final RestaurantSecurityService restaurantSecurityService;


    // Helper method to map Restaurant Entity to RestaurantResponseDto
    private RestaurantResponseDto mapToRestaurantResponseDto(Restaurant restaurant) {
        if (restaurant == null) {
            return null;
        }
        return new RestaurantResponseDto(
                restaurant.getId(),
                restaurant.getName(),
                restaurant.getDescription(),
                restaurant.getAddress(),
                restaurant.getPhoneNumber(),
                restaurant.getEmail(),
                restaurant.isActive(),
                restaurant.getCreatedAt(),
                restaurant.getUpdatedAt()
        );
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Create a new restaurant",
               description = "Creates a new restaurant. Requires ADMIN role.",
               responses = {
                   @ApiResponse(responseCode = "201", description = "Restaurant created successfully",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "400", description = "Invalid input data (e.g., validation error)", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized - JWT token is missing or invalid", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden - User does not have ADMIN role", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "409", description = "Conflict - Restaurant name or email already exists", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<RestaurantResponseDto> createRestaurant(
            @Valid @RequestBody CreateRestaurantRequestDto createDto) {
        LOGGER.info("API call to create restaurant with name: {}", createDto.getName());
        Restaurant createdRestaurant = restaurantService.createRestaurant(createDto);
        LOGGER.info("Restaurant created with ID: {}", createdRestaurant.getId());
        return new ResponseEntity<>(mapToRestaurantResponseDto(createdRestaurant), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("isAuthenticated()") // Allows any authenticated user to view restaurant details. Adjust if needed.
    @Operation(summary = "Get a restaurant by ID",
               description = "Retrieves details of a specific restaurant by its ID. Accessible by any authenticated user.",
               responses = {
                   @ApiResponse(responseCode = "200", description = "Restaurant found",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden (if specific role checks were added and failed)", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "404", description = "Restaurant not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<RestaurantResponseDto> getRestaurantById(@PathVariable Long id) {
        LOGGER.debug("API call to get restaurant by ID: {}", id);
        Restaurant restaurant = restaurantService.findRestaurantById(id);
        return ResponseEntity.ok(mapToRestaurantResponseDto(restaurant));
    }

    @GetMapping
    @PreAuthorize("isAuthenticated()") // Allows any authenticated user to list restaurants.
    @Operation(summary = "Get all restaurants",
               description = "Retrieves a list of all restaurants. Accessible by any authenticated user. (Pagination to be added later)",
               responses = {
                   @ApiResponse(responseCode = "200", description = "List of restaurants retrieved",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<List<RestaurantResponseDto>> getAllRestaurants() {
        // TODO: Implement pagination (e.g., using Pageable) and filtering
        LOGGER.debug("API call to get all restaurants");
        List<Restaurant> restaurants = restaurantService.findAllRestaurants();
        List<RestaurantResponseDto> responseDtos = restaurants.stream()
                .map(this::mapToRestaurantResponseDto)
                .collect(Collectors.toList());
        return ResponseEntity.ok(responseDtos);
    }

    @PutMapping("/{id}")
    // Option 1: Simple ADMIN only
    // @PreAuthorize("hasRole('ADMIN')")
    // Option 2: ADMIN or specific RESTAURANT_ADMIN (requires custom RestaurantSecurityService)
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @restaurantSecurityServiceImpl.isRestaurantAdminForRestaurant(#id, principal.username))")
    @Operation(summary = "Update an existing restaurant",
               description = "Updates details of an existing restaurant. Requires ADMIN role, or RESTAURANT_ADMIN role for the specific restaurant if `RestaurantSecurityService` is implemented.",
               responses = {
                   @ApiResponse(responseCode = "200", description = "Restaurant updated successfully",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "400", description = "Invalid input data", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "404", description = "Restaurant not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "409", description = "Conflict - Updated name or email already exists", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<RestaurantResponseDto> updateRestaurant(
            @PathVariable Long id,
            @Valid @RequestBody UpdateRestaurantRequestDto updateDto) {
        LOGGER.info("API call to update restaurant with ID: {}", id);
        Restaurant updatedRestaurant = restaurantService.updateRestaurant(id, updateDto);
        LOGGER.info("Restaurant with ID: {} updated successfully", updatedRestaurant.getId());
        return ResponseEntity.ok(mapToRestaurantResponseDto(updatedRestaurant));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Delete a restaurant by ID",
               description = "Deletes a specific restaurant by its ID. Requires ADMIN role.",
               responses = {
                   @ApiResponse(responseCode = "204", description = "Restaurant deleted successfully"),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden - User does not have ADMIN role", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "404", description = "Restaurant not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<Void> deleteRestaurant(@PathVariable Long id) {
        LOGGER.info("API call to delete restaurant with ID: {}", id);
        restaurantService.deleteRestaurant(id);
        LOGGER.info("Restaurant with ID: {} deleted successfully", id);
        return ResponseEntity.noContent().build();
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/UserController.java ===
package com.multirestaurantplatform.api.controller;

import com.multirestaurantplatform.security.dto.UserResponseDto;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/users") // Base path for user-related endpoints
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    // Endpoint to get a user by username
    @GetMapping("/username/{username}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponseDto> getUserByUsername(@PathVariable String username) {
        User user = userService.findUserByUsername(username);
        UserResponseDto userResponseDto = mapToUserResponseDto(user);
        return ResponseEntity.ok(userResponseDto);
    }

    // New Endpoint: Get a user by ID
    @GetMapping("/id/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponseDto> getUserById(@PathVariable Long id) {
        User user = userService.findUserById(id);
        UserResponseDto userResponseDto = mapToUserResponseDto(user);
        return ResponseEntity.ok(userResponseDto);
    }

    // New Endpoint: Get a user by email
    @GetMapping("/email/{email}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponseDto> getUserByEmail(@PathVariable String email) {
        User user = userService.findUserByEmail(email); // Assuming email path variable should be URL-friendly
        // For emails, sometimes using a request param is preferred
        // e.g., /users/search?email=user@example.com
        // But /email/{email} is also common.
        UserResponseDto userResponseDto = mapToUserResponseDto(user);
        return ResponseEntity.ok(userResponseDto);
    }

    // Helper method to map User entity to UserResponseDto
    private UserResponseDto mapToUserResponseDto(User user) {
        if (user == null) {
            return null; // Should not happen if service throws ResourceNotFoundException
        }
        return new UserResponseDto(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getRoles()
        );
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/auth/AuthController.java ===
package com.multirestaurantplatform.api.controller.auth;

import com.multirestaurantplatform.security.dto.JwtAuthenticationResponse;
import com.multirestaurantplatform.security.dto.LoginRequest;
import com.multirestaurantplatform.security.dto.RegisterRequest;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.service.JwtService;
import com.multirestaurantplatform.security.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/auth") // Base path for authentication-related endpoints
@RequiredArgsConstructor // Lombok: Creates constructor for all final fields
public class AuthController {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuthController.class);

    private final UserService userService;
    private final AuthenticationManager authenticationManager; // For authenticating users
    private final JwtService jwtService;                     // For generating JWT tokens

    // In AuthController.java
    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@Valid @RequestBody RegisterRequest registerRequest) {
        // Remove the try-catch block for RuntimeException
        User registeredUser = userService.registerUser(registerRequest); // Let exceptions propagate

        // Consider returning a different DTO instead of the full User entity to avoid exposing too much.
        // For now, a success message or a simplified representation is fine.
        LOGGER.info("User registered successfully: {}", registeredUser.getUsername());

        // For consistency, you might want to consider returning a JSON response even for success.
        // Example:
        // Map<String, String> responseBody = Map.of("message", "User registered successfully with username: " + registeredUser.getUsername());
        // return ResponseEntity.status(HttpStatus.CREATED).body(responseBody);
        return ResponseEntity.status(HttpStatus.CREATED).body("User registered successfully with username: " + registeredUser.getUsername());
    }

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        try {
            // Attempt to authenticate the user using Spring Security's AuthenticationManager
            // This will use your UserDetailsServiceImpl to load the user and check credentials
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()
                    )
            );

            // If authentication is successful, set the authentication in the SecurityContext
            SecurityContextHolder.getContext().setAuthentication(authentication);

            // The principal is now an instance of UserDetails (as returned by your UserDetailsServiceImpl)
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();

            // Generate JWT token using our JwtService
            String jwt = jwtService.generateToken(userDetails);

            LOGGER.info("User authenticated successfully: {}", userDetails.getUsername());
            // Return the JWT in the response
            return ResponseEntity.ok(new JwtAuthenticationResponse(jwt));

        } catch (BadCredentialsException e) {
            LOGGER.warn("Authentication failed for user {}: Invalid credentials", loginRequest.getUsername());
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Error: Invalid username or password");
        } catch (Exception e) {
            LOGGER.error("Authentication error for user {}: {}", loginRequest.getUsername(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: An internal server error occurred during authentication.");
        }
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/exception/GlobalExceptionHandler.java ===
package com.multirestaurantplatform.api.exception;

// ... other imports
import com.multirestaurantplatform.common.exception.BadRequestException; // Added
import com.multirestaurantplatform.common.exception.ConflictException; // Added
import com.multirestaurantplatform.common.exception.ResourceNotFoundException; // Added
import com.multirestaurantplatform.api.dto.error.ErrorResponse; // Added

import jakarta.servlet.http.HttpServletRequest; // Added if not present, or use WebRequest
import org.slf4j.Logger; // Added
import org.slf4j.LoggerFactory; // Added
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
// ...

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    private static final Logger customLogger = LoggerFactory.getLogger(GlobalExceptionHandler.class); // Renamed to avoid conflict if 'logger' is in parent

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers,
            HttpStatusCode status, WebRequest request) {

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now().toString()); // Consider LocalDateTime directly if ErrorResponse is adapted
        body.put("status", status.value());
        body.put("error", "Bad Request"); // Or HttpStatus.BAD_REQUEST.getReasonPhrase()

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());
        body.put("errors", errors); // This "errors" field is specific to validation

        String path = "";
        if (request != null && request.getDescription(false) != null) {
            path = request.getDescription(false).replace("uri=", "");
            body.put("path", path);
        }
        customLogger.warn("MethodArgumentNotValidException: {} errors for path {}: {}", ex.getBindingResult().getErrorCount(), path, errors);
        return new ResponseEntity<>(body, headers, status);
    }

    // --- New Handlers for Custom Exceptions ---

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(
            ResourceNotFoundException ex, HttpServletRequest request) { // Using HttpServletRequest for simplicity here
        customLogger.warn("ResourceNotFoundException: {} at path {}", ex.getMessage(), request.getRequestURI());
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.NOT_FOUND.value(),
                HttpStatus.NOT_FOUND.getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(
            BadRequestException ex, HttpServletRequest request) {
        customLogger.warn("BadRequestException: {} at path {}", ex.getMessage(), request.getRequestURI());
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                HttpStatus.BAD_REQUEST.getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(
            ConflictException ex, HttpServletRequest request) {
        customLogger.warn("ConflictException: {} at path {}", ex.getMessage(), request.getRequestURI());
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.CONFLICT.value(),
                HttpStatus.CONFLICT.getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(
            AccessDeniedException ex, HttpServletRequest request) {
        customLogger.warn("AccessDeniedException: {} for path {}", ex.getMessage(), request.getRequestURI()); // Log as WARN or INFO
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.FORBIDDEN.value(),
                HttpStatus.FORBIDDEN.getReasonPhrase(),
                "Access Denied: You do not have the necessary permissions to access this resource.", // Or ex.getMessage() if you prefer
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // --- Fallback Handler ---
    // This handles any other exceptions not specifically caught above or by ResponseEntityExceptionHandler
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex, HttpServletRequest request) {
        // Avoid logging known Spring Security exceptions like AccessDeniedException twice if already handled by Spring Security
        // Or if you have specific handlers for them
        customLogger.error("Unhandled Exception: {} at path {}", ex.getMessage(), request.getRequestURI(), ex);
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "An unexpected internal server error occurred.", // Generic message to client
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
=== gradle/wrapper/gradle-wrapper.jar ===
=== gradle/wrapper/gradle-wrapper.properties ===
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
LLM Instructions:
Hello LLM, I need your assistance in developing and improving my application while being careful not breaking the current working app. The project already been started and is progressing. the "Multi‑Restaurant Platform." I will guide … (full block omitted for brevity in code; emitted verbatim at the end).