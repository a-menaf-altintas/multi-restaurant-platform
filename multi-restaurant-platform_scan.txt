Project Name: multi-restaurant-platform
Project Summary:
# Multi‚ÄëRestaurant Platform

A **modular, container‚Äëready Spring¬†Boot‚ÄØ3 (Java‚ÄØ21) backend** designed to power multi‚Äërestaurant ordering, management, and (eventually) delivery experiences.

> **Why this repo exists**‚ÄÉThe author rebuilt the project *from scratch* after an earlier ‚Äúbig‚Äëbang‚Äù attempt generated too many errors to untangle.  Everything here is meant to be grown **one small, reviewed step at a time**‚Äîyou‚Äôll see that philosophy reflected throughout this README.

---

## 1¬†¬†Features (current & planned)

| Status | Domain                 | Highlights                                                                          |
| ------ | ---------------------- | ----------------------------------------------------------------------------------- |
| ¬†‚úÖ¬†    | **Authentication**     | JWT‚Äëbased login / registration, role model (ADMIN, RESTAURANT\_ADMIN, CUSTOMER)     |
| ¬†‚úÖ¬†    | **Restaurant¬†&¬†Menu**  | CRUD for restaurants, categories, items (with media & options)                      |
| ¬†‚úÖ¬†   | **Order¬†Flow**         | Cart ‚Üí order ‚Üí status timeline (PLACED¬†‚Üí¬†CONFIRMED¬†‚Üí¬†PREPARING¬†‚Üí¬†READY¬†‚Üí¬†DELIVERED) |
| ¬†üü°¬†   | **Payments**           | Stripe integration stub (test keys) with webhook listener                           |
| ¬†üü°¬†   | **WebSocket¬†Printing** | Real‚Äëtime receipt / KDS ticket streaming to browser printers                        |
| ¬†üî≤¬†   | **Admin¬†Dashboard**    | CMS pages, global config, analytics                                                 |

Legend: ‚úÖ¬†finished ¬∑ üü°¬†in progress ¬∑ üî≤¬†not started

---

## 2¬†¬†Tech¬†Stack

| Layer       | Choice                                   | Notes                                                      |
| ----------- | ---------------------------------------- | ---------------------------------------------------------- |
| Language    | **Java¬†21**                              | Modern features (records, sealed classes, virtual threads) |
| Framework   | **Spring¬†Boot¬†3.2.x**                    | Modular (each sub‚Äëmodule is its own Spring¬†Boot project)   |
[DIR] .
[DIR] backend
[DIR] backend/order
[DIR] backend/order/src
[DIR] backend/order/src/test
[DIR] backend/order/src/test/resources
[DIR] backend/order/src/test/java
[DIR] backend/order/src/test/java/com
[DIR] backend/order/src/test/java/com/multirestaurantplatform
[DIR] backend/order/src/test/java/com/multirestaurantplatform/order
[DIR] backend/order/src/test/java/com/multirestaurantplatform/order/config
[DIR] backend/order/src/test/java/com/multirestaurantplatform/order/controller
[DIR] backend/order/src/test/java/com/multirestaurantplatform/order/service
[DIR] backend/order/src/test/java/com/multirestaurantplatform/order/service/impl
[DIR] backend/order/src/main
[DIR] backend/order/src/main/resources
[DIR] backend/order/src/main/java
[DIR] backend/order/src/main/java/com
[DIR] backend/order/src/main/java/com/multirestaurantplatform
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/dto
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/repository
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/controller
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/model
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/model/cart
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/service
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/service/impl
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/service/client
[DIR] backend/order/src/main/java/com/multirestaurantplatform/order/exception
[DIR] backend/restaurant
[DIR] backend/restaurant/src
[DIR] backend/restaurant/src/test
[DIR] backend/restaurant/src/test/resources
[DIR] backend/restaurant/src/test/java
[DIR] backend/restaurant/src/test/java/com
[DIR] backend/restaurant/src/test/java/com/multirestaurantplatform
[DIR] backend/restaurant/src/test/java/com/multirestaurantplatform/restaurant
[DIR] backend/restaurant/src/test/java/com/multirestaurantplatform/restaurant/service
[DIR] backend/restaurant/src/main
[DIR] backend/restaurant/src/main/resources
[DIR] backend/restaurant/src/main/java
[DIR] backend/restaurant/src/main/java/com
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/repository
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/model
[DIR] backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service
[DIR] backend/security
[DIR] backend/security/src
[DIR] backend/security/src/test
[DIR] backend/security/src/test/resources
[DIR] backend/security/src/test/java
[DIR] backend/security/src/test/java/com
[DIR] backend/security/src/test/java/com/multirestaurantplatform
[DIR] backend/security/src/test/java/com/multirestaurantplatform/security
[DIR] backend/security/src/test/java/com/multirestaurantplatform/security/service
[DIR] backend/security/src/main
[DIR] backend/security/src/main/resources
[DIR] backend/security/src/main/java
[DIR] backend/security/src/main/java/com
[DIR] backend/security/src/main/java/com/multirestaurantplatform
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/dto
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/repository
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/config
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/model
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/filter
[DIR] backend/security/src/main/java/com/multirestaurantplatform/security/service
[DIR] backend/payment
[DIR] backend/payment/src
[DIR] backend/payment/src/test
[DIR] backend/payment/src/test/resources
[DIR] backend/payment/src/test/java
[DIR] backend/payment/src/main
[DIR] backend/payment/src/main/resources
[DIR] backend/payment/src/main/java
[DIR] backend/admin
[DIR] backend/admin/src
[DIR] backend/admin/src/test
[DIR] backend/admin/src/test/resources
[DIR] backend/admin/src/test/java
[DIR] backend/admin/src/main
[DIR] backend/admin/src/main/resources
[DIR] backend/admin/src/main/java
[DIR] backend/print
[DIR] backend/print/src
[DIR] backend/print/src/test
[DIR] backend/print/src/test/resources
[DIR] backend/print/src/test/java
[DIR] backend/print/src/main
[DIR] backend/print/src/main/resources
[DIR] backend/print/src/main/java
[DIR] backend/common
[DIR] backend/common/src
[DIR] backend/common/src/test
[DIR] backend/common/src/test/resources
[DIR] backend/common/src/test/java
[DIR] backend/common/src/main
[DIR] backend/common/src/main/resources
[DIR] backend/common/src/main/java
[DIR] backend/common/src/main/java/com
[DIR] backend/common/src/main/java/com/multirestaurantplatform
[DIR] backend/common/src/main/java/com/multirestaurantplatform/common
[DIR] backend/common/src/main/java/com/multirestaurantplatform/common/model
[DIR] backend/common/src/main/java/com/multirestaurantplatform/common/exception
[DIR] backend/menu
[DIR] backend/menu/src
[DIR] backend/menu/src/test
[DIR] backend/menu/src/test/resources
[DIR] backend/menu/src/test/java
[DIR] backend/menu/src/test/java/com
[DIR] backend/menu/src/test/java/com/multirestaurantplatform
[DIR] backend/menu/src/test/java/com/multirestaurantplatform/menu
[DIR] backend/menu/src/test/java/com/multirestaurantplatform/menu/service
[DIR] backend/menu/src/main
[DIR] backend/menu/src/main/resources
[DIR] backend/menu/src/main/java
[DIR] backend/menu/src/main/java/com
[DIR] backend/menu/src/main/java/com/multirestaurantplatform
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/dto
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/repository
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/model
[DIR] backend/menu/src/main/java/com/multirestaurantplatform/menu/service
[DIR] backend/api
[DIR] backend/api/src
[DIR] backend/api/src/test
[DIR] backend/api/src/test/resources
[DIR] backend/api/src/test/java
[DIR] backend/api/src/test/java/com
[DIR] backend/api/src/test/java/com/multirestaurantplatform
[DIR] backend/api/src/test/java/com/multirestaurantplatform/api
[DIR] backend/api/src/test/java/com/multirestaurantplatform/api/controller
[DIR] backend/api/src/test/java/com/multirestaurantplatform/api/controller/auth
[DIR] backend/api/src/test/java/com/multirestaurantplatform/api/e2e
[DIR] backend/api/src/main
[DIR] backend/api/src/main/resources
[DIR] backend/api/src/main/resources/db
[DIR] backend/api/src/main/resources/db/migration
[DIR] backend/api/src/main/java
[DIR] backend/api/src/main/java/com
[DIR] backend/api/src/main/java/com/multirestaurantplatform
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/dto
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/dto/error
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/config
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/payload
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/controller
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/controller/auth
[DIR] backend/api/src/main/java/com/multirestaurantplatform/api/exception
[DIR] gradle
[DIR] gradle/wrapper
=== .env ===
=== .gitignore ===
# Gradle
.gradle
build/
!build/tmp/checkstyle/ # Example if you want to keep checkstyle reports but ignore rest of build

# IntelliJ IDEA
.idea/
*.iml
*.ipr
*.iws
out/
shelf/ # IntelliJ shelf
workspace.xml # IntelliJ workspace file (often in .idea)

# Spring Boot specific
target/ # Though we use build/, some tools might generate target/

# Maven (in case it's ever used or for consistency)
# target/
# pom.xml.tag
# pom.xml.releaseBackup
# pom.xml.versionsBackup
# release.properties
# dependency-reduced-pom.xml
# buildNumber.properties

# Log files
*.log
logs/

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Environment variables file
.env
*.env
.env.*
!.env.example # Keep example env files if you have them

# Compiled files
*.class
*.jar
*.war
*.ear

# Package Files #
# --------------- #
# *.jar
# *.war
# *.nar
# *.ear
# *.zip
# *.tar.gz
# *.rpm
# *.deb

# Sensitive information
credentials.*
secrets.*

# Local settings
local.properties

# Node / NPM (in case you add frontend directly in the same root later without a separate gitignore)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json # often committed, but sometimes ignored in library projects
yarn.lock # often committed

# VS Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Gradle Wrapper
# We usually commit the wrapper jar but if you choose not to:
# !gradle/wrapper/gradle-wrapper.jar
=== Dockerfile ===
# Stage 1: Build the application using Gradle
FROM gradle:8.7-jdk21 AS build
# The gradle image tag should match a version compatible with your project and JDK.
# Using gradle:8.7-jdk21 since your project uses Java 21 and Gradle 8.x.
# The README.md.pdf also mentioned gradle:8.0-jdk21. Using a slightly newer patch like 8.7 is fine.

WORKDIR /app
# Copy only the files necessary for dependency resolution first to leverage Docker cache
COPY build.gradle settings.gradle /app/
COPY backend/build.gradle /app/backend/
COPY backend/api/build.gradle /app/backend/api/
# If other modules' build.gradle files are needed for resolving api dependencies, copy them too.
# For now, assuming api's dependencies are self-contained or pulled via 'project(...)' correctly.

# Copy the rest of the source code
COPY . /app/
# Grant execution rights to gradlew
RUN chmod +x ./gradlew
# Build the application, targeting the api module's bootJar task
RUN ./gradlew :backend:api:bootJar --no-daemon

# Stage 2: Create the runtime image (This is the part you posted and looks good)
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build /app/backend/api/build/libs/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
=== README.md ===
=== build.gradle ===
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.5' apply false // Define Spring Boot plugin version for all modules
    id 'io.spring.dependency-management' version '1.1.4' // Define & apply dependency management globally
}

// Define common versions in extra properties for easy updates
ext {
    lombokVersion = '1.18.32' // Use a recent, stable Lombok version
    springBootVersion = '3.2.5' // Match the plugin version
    springDocOpenapiVersion = '2.5.0' // Define springdoc version here too
}

allprojects {
    group = 'com.multirestaurantplatform'
    version = '0.0.1-SNAPSHOT'

    repositories {
        mavenCentral()
    }

    // Apply dependency management to ALL projects
    apply plugin: 'io.spring.dependency-management'

    dependencyManagement {
        imports {
            // Import Spring Boot's BOM - this defines versions for Boot dependencies
            mavenBom "org.springframework.boot:spring-boot-dependencies:${springBootVersion}"
        }
        dependencies {
            // Define versions for other direct dependencies we want to manage
            dependency "org.projectlombok:lombok:${lombokVersion}"
            dependency "org.springdoc:springdoc-openapi-starter-webmvc-ui:${springDocOpenapiVersion}"
        }
    }
}

subprojects {
    apply plugin: 'java' // Apply java plugin to all subprojects

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    // Common dependencies for all subprojects
    dependencies {
        // Lombok - version is managed by dependencyManagement
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'
        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'
    }

    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }

    tasks.withType(Test) {
        useJUnitPlatform()
    }
}
=== create_package.sh ===
=== docker-compose.yml ===
version: '3.8'

services:
  multi-restaurant-api:
    build:
      context: .
      dockerfile: Dockerfile
    image: multi-restaurant-platform-backend
    container_name: multi-restaurant-platform
    ports:
      - "8081:8080" # HOST_PORT:CONTAINER_PORT - Access on Mac via 8081, app in container runs on 8080
    environment:
      - SERVER_PORT=8080 # Spring Boot app inside container will listen on port 8080
      # - SPRING_PROFILES_ACTIVE=dev
    restart: unless-stopped
=== gradlew ===
=== gradlew.bat ===
=== multi-restaurant-platform_scan.txt ===
=== scan_project_chatGPT.py ===
=== scan_project_claude.py ===
=== scan_project_gemini.py ===
=== scan_project_gemini2.py ===
=== settings.gradle ===
// File: settings.gradle
rootProject.name = 'multi-restaurant-platform'

include 'backend'
include 'backend:common'
include 'backend:security'
include 'backend:restaurant'
include 'backend:menu'
include 'backend:order'
include 'backend:payment'
include 'backend:print'
include 'backend:admin'
include 'backend:api'
=== backend/build.gradle ===
// File: multi-restaurant-platform/backend/build.gradle
plugins {
    id 'java'
}

description = 'Parent module for all backend services'

subprojects {
    apply plugin: 'java' // Ensure java plugin is applied

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    // Add this block to enable the -parameters flag for Java compilation
    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
        options.compilerArgs += '-parameters' // Add this line
    }

    // Common dependencies for all subprojects
    dependencies {
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'
        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'
    }

    tasks.withType(Test) {
        useJUnitPlatform()
    }
}
=== backend/order/build.gradle ===
// File: backend/order/build.gradle
plugins {
    id 'java-library'
}

description = 'The order module - defines order entities, cart functionality, and order workflow services/repositories'

dependencies {
    // For Jakarta Persistence API (JPA) entities and Spring Data JPA
    // Version is managed by the Spring Boot BOM in the root project.
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    // For using validation annotations like @NotNull, @Min etc. in DTOs and Entities
    // Version is managed by the Spring Boot BOM in the root project.
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // For Spring Web (needed for @RestController, @RequestMapping, ResponseEntity, etc. in OrderController)
    // Also brings in core Spring framework classes.
    // Version is managed by the Spring Boot BOM in the root project.
    implementation 'org.springframework.boot:spring-boot-starter-web'

    // Explicitly add Spring Boot Starter Security to ensure all security annotations and classes
    // (like @PreAuthorize, UserDetails, @AuthenticationPrincipal, AccessDeniedException) are available directly to this module.
    // Version is managed by the Spring Boot BOM in the root project.
    implementation 'org.springframework.boot:spring-boot-starter-security'

    // For OpenAPI 3.0 (Swagger) annotations and UI generation
    // Version ('org.springdoc:springdoc-openapi-starter-webmvc-ui') is managed by the root build.gradle's dependencyManagement.
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui'

    // Dependency on the common module (for BaseEntity, custom exceptions like ResourceNotFoundException)
    implementation project(':backend:common')

    // Dependency on the security module (for User model, Role enum, UserRepository, and potentially custom UserDetails implementations)
    // This module provides your application-specific security logic and models.
    implementation project(':backend:security')

    // Dependency on the restaurant module (for Restaurant model, RestaurantRepository, used for authorization checks in OrderService)
    implementation project(':backend:restaurant')

    // Lombok is managed by the root project's subprojects configuration (compileOnly and annotationProcessor).
    // No need to declare version here.
    // compileOnly 'org.projectlombok:lombok'
    // annotationProcessor 'org.projectlombok:lombok'

    // --- Test Dependencies ---
    // Versions are managed by the Spring Boot BOM in the root project.
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test' // For @WithMockUser and other security testing utilities

    // Test dependency on the api module (e.g., if tests need GlobalExceptionHandler or ErrorResponse DTO from the api module)
    // This was existing for CartControllerTest. Keep if still relevant for order tests.
    testImplementation project(':backend:api')
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/dto/AddItemToCartRequest.java ===
package com.multirestaurantplatform.order.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;

public class AddItemToCartRequest {
    @NotNull(message = "Restaurant ID cannot be null")
    private Long restaurantId;

    @NotNull(message = "Menu item ID cannot be null")
    private Long menuItemId;

    @NotNull(message = "Quantity cannot be null")
    @Min(value = 1, message = "Quantity must be at least 1")
    private Integer quantity;

    // Constructors, Getters, and Setters
    public AddItemToCartRequest() {
    }

    public AddItemToCartRequest(Long restaurantId, Long menuItemId, Integer quantity) {
        this.restaurantId = restaurantId;
        this.menuItemId = menuItemId;
        this.quantity = quantity;
    }

    public Long getRestaurantId() {
        return restaurantId;
    }

    public void setRestaurantId(Long restaurantId) {
        this.restaurantId = restaurantId;
    }

    public Long getMenuItemId() {
        return menuItemId;
    }

    public void setMenuItemId(Long menuItemId) {
        this.menuItemId = menuItemId;
    }

    public Integer getQuantity() {
        return quantity;
    }

    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/dto/CartItemResponse.java ===
package com.multirestaurantplatform.order.dto;

import java.math.BigDecimal;

public class CartItemResponse {
    private Long menuItemId;
    private String menuItemName;
    private Integer quantity;
    private BigDecimal unitPrice;
    private BigDecimal totalPrice;

    // Constructors, Getters, and Setters
    public CartItemResponse() {
    }

    public CartItemResponse(Long menuItemId, String menuItemName, Integer quantity, BigDecimal unitPrice, BigDecimal totalPrice) {
        this.menuItemId = menuItemId;
        this.menuItemName = menuItemName;
        this.quantity = quantity;
        this.unitPrice = unitPrice;
        this.totalPrice = totalPrice;
    }

    // ... (make sure all getters and setters are present as per the previous full code block) ...
    public Long getMenuItemId() { return menuItemId; }
    public void setMenuItemId(Long menuItemId) { this.menuItemId = menuItemId; }
    public String getMenuItemName() { return menuItemName; }
    public void setMenuItemName(String menuItemName) { this.menuItemName = menuItemName; }
    public Integer getQuantity() { return quantity; }
    public void setQuantity(Integer quantity) { this.quantity = quantity; }
    public BigDecimal getUnitPrice() { return unitPrice; }
    public void setUnitPrice(BigDecimal unitPrice) { this.unitPrice = unitPrice; }
    public BigDecimal getTotalPrice() { return totalPrice; }
    public void setTotalPrice(BigDecimal totalPrice) { this.totalPrice = totalPrice; }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/dto/CartResponse.java ===
package com.multirestaurantplatform.order.dto;

import java.math.BigDecimal;
import java.util.List;

public class CartResponse {
    private String userId;
    private Long restaurantId;
    private String restaurantName;
    private List<CartItemResponse> items;
    private BigDecimal cartTotalPrice;

    // Constructors, Getters, and Setters
    public CartResponse() {
    }

    public CartResponse(String userId, Long restaurantId, String restaurantName, List<CartItemResponse> items, BigDecimal cartTotalPrice) {
        this.userId = userId;
        this.restaurantId = restaurantId;
        this.restaurantName = restaurantName;
        this.items = items;
        this.cartTotalPrice = cartTotalPrice;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public Long getRestaurantId() {
        return restaurantId;
    }

    public void setRestaurantId(Long restaurantId) {
        this.restaurantId = restaurantId;
    }

    public String getRestaurantName() {
        return restaurantName;
    }

    public void setRestaurantName(String restaurantName) {
        this.restaurantName = restaurantName;
    }

    public List<CartItemResponse> getItems() {
        return items;
    }

    public void setItems(List<CartItemResponse> items) {
        this.items = items;
    }

    public BigDecimal getCartTotalPrice() {
        return cartTotalPrice;
    }

    public void setCartTotalPrice(BigDecimal cartTotalPrice) {
        this.cartTotalPrice = cartTotalPrice;
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/dto/OrderItemResponse.java ===
package com.multirestaurantplatform.order.dto;

import com.multirestaurantplatform.order.model.OrderItem; // Ensure correct import
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemResponse {
    private Long id;
    private Long menuItemId;
    private String menuItemName;
    private Integer quantity;
    private BigDecimal unitPrice;
    private BigDecimal itemTotalPrice;
    private String selectedOptions;

    public static OrderItemResponse fromEntity(OrderItem orderItem) {
        if (orderItem == null) {
            return null;
        }
        return new OrderItemResponse(
                orderItem.getId(),
                orderItem.getMenuItemId(),
                orderItem.getMenuItemName(),
                orderItem.getQuantity(),
                orderItem.getUnitPrice(),
                orderItem.getItemTotalPrice(),
                orderItem.getSelectedOptions()
        );
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/dto/OrderResponse.java ===
// File: backend/order/src/main/java/com/multirestaurantplatform/order/dto/OrderResponse.java
package com.multirestaurantplatform.order.dto;

import com.multirestaurantplatform.order.model.Order;
import com.multirestaurantplatform.order.model.OrderStatus;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Getter
@Setter
@NoArgsConstructor
// Update AllArgsConstructor or add a new constructor if you prefer manual control
public class OrderResponse {

    private Long id;
    private Long customerId;
    private Long restaurantId;
    private OrderStatus status;
    private BigDecimal totalPrice;
    private String deliveryAddressLine1;
    private String deliveryCity;
    private String deliveryPostalCode;
    private String customerContactNumber;
    private String specialInstructions;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private LocalDateTime placedAt;
    private LocalDateTime confirmedAt;
    private LocalDateTime preparingAt;
    private LocalDateTime readyAt;
    private LocalDateTime outForDeliveryAt; // New field
    private LocalDateTime deliveredAt;
    private LocalDateTime cancelledAt;
    private List<OrderItemResponse> orderItems;

    // Manual constructor to include the new field
    public OrderResponse(Long id, Long customerId, Long restaurantId, OrderStatus status, BigDecimal totalPrice,
                         String deliveryAddressLine1, String deliveryCity, String deliveryPostalCode,
                         String customerContactNumber, String specialInstructions, LocalDateTime createdAt,
                         LocalDateTime updatedAt, LocalDateTime placedAt, LocalDateTime confirmedAt,
                         LocalDateTime preparingAt, LocalDateTime readyAt, LocalDateTime outForDeliveryAt,
                         LocalDateTime deliveredAt, LocalDateTime cancelledAt, List<OrderItemResponse> orderItems) {
        this.id = id;
        this.customerId = customerId;
        this.restaurantId = restaurantId;
        this.status = status;
        this.totalPrice = totalPrice;
        this.deliveryAddressLine1 = deliveryAddressLine1;
        this.deliveryCity = deliveryCity;
        this.deliveryPostalCode = deliveryPostalCode;
        this.customerContactNumber = customerContactNumber;
        this.specialInstructions = specialInstructions;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.placedAt = placedAt;
        this.confirmedAt = confirmedAt;
        this.preparingAt = preparingAt;
        this.readyAt = readyAt;
        this.outForDeliveryAt = outForDeliveryAt;
        this.deliveredAt = deliveredAt;
        this.cancelledAt = cancelledAt;
        this.orderItems = orderItems;
    }


    // Static factory method to convert Order entity to OrderResponse DTO
    public static OrderResponse fromEntity(Order order) {
        if (order == null) {
            return null;
        }
        List<OrderItemResponse> itemResponses = order.getOrderItems() != null ?
                order.getOrderItems().stream().map(OrderItemResponse::fromEntity).collect(Collectors.toList()) :
                List.of();

        return new OrderResponse(
                order.getId(),
                order.getCustomerId(),
                order.getRestaurantId(),
                order.getStatus(),
                order.getTotalPrice(),
                order.getDeliveryAddressLine1(),
                order.getDeliveryCity(),
                order.getDeliveryPostalCode(),
                order.getCustomerContactNumber(),
                order.getSpecialInstructions(),
                order.getCreatedAt(),
                order.getUpdatedAt(),
                order.getPlacedAt(),
                order.getConfirmedAt(),
                order.getPreparingAt(),
                order.getReadyAt(),
                order.getOutForDeliveryAt(), // Include new field
                order.getDeliveredAt(),
                order.getCancelledAt(),
                itemResponses
        );
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/dto/UpdateCartItemRequest.java ===
package com.multirestaurantplatform.order.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;

public class UpdateCartItemRequest {
    @NotNull(message = "Quantity cannot be null")
    @Min(value = 1, message = "Quantity must be at least 1")
    private Integer quantity;

    // Constructors, Getters, and Setters
    public UpdateCartItemRequest() {
    }

    public UpdateCartItemRequest(Integer quantity) {
        this.quantity = quantity;
    }

    public Integer getQuantity() {
        return quantity;
    }

    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/repository/OrderRepository.java ===
package com.multirestaurantplatform.order.repository;

import com.multirestaurantplatform.order.model.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    // You can add custom query methods here if needed in the future
    // For example:
    // List<Order> findByCustomerIdAndStatus(Long customerId, OrderStatus status);
    // List<Order> findByRestaurantIdAndStatus(Long restaurantId, OrderStatus status);
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/controller/CartController.java ===
package com.multirestaurantplatform.order.controller;

import com.multirestaurantplatform.order.dto.AddItemToCartRequest;
import com.multirestaurantplatform.order.dto.CartResponse;
import com.multirestaurantplatform.order.dto.UpdateCartItemRequest;
import com.multirestaurantplatform.order.service.CartService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

// Note: Ensure spring-security-core is a dependency if @AuthenticationPrincipal is to be used.
// import org.springframework.security.core.annotation.AuthenticationPrincipal;

@RestController
@RequestMapping("/api/v1/users/{userId}/cart") // Using userId in path for explicit context
@Tag(name = "Cart API", description = "Operations pertaining to user shopping cart")
public class CartController {

    private final CartService cartService;

    @Autowired
    public CartController(CartService cartService) {
        this.cartService = cartService;
    }

    @Operation(summary = "Add an item to the user's cart",
            description = "Adds a specified quantity of a menu item to the cart. If the cart or item does not exist, it will be created. If adding from a different restaurant, current cart may be cleared.")
    @ApiResponse(responseCode = "200", description = "Item added successfully, returns updated cart")
    @ApiResponse(responseCode = "400", description = "Invalid request (e.g., item not found, validation error)")
    @PostMapping("/items")
    public ResponseEntity<CartResponse> addItemToCart(
            @Parameter(description = "ID of the user whose cart is being modified") @PathVariable("userId") String userId, // Explicitly named
            @Valid @RequestBody AddItemToCartRequest addItemRequest) {
        // In a real app with Spring Security, you might get userId from @AuthenticationPrincipal
        CartResponse cartResponse = cartService.addItemToCart(userId, addItemRequest);
        return ResponseEntity.ok(cartResponse);
    }

    @Operation(summary = "Get the user's current cart")
    @ApiResponse(responseCode = "200", description = "Successfully retrieved cart")
    @GetMapping
    public ResponseEntity<CartResponse> getCart(
            @Parameter(description = "ID of the user whose cart is being retrieved") @PathVariable("userId") String userId) { // Explicitly named
        CartResponse cartResponse = cartService.getCart(userId);
        return ResponseEntity.ok(cartResponse);
    }

    @Operation(summary = "Update quantity of an item in the cart",
            description = "Updates the quantity of a specific menu item already in the cart.")
    @ApiResponse(responseCode = "200", description = "Item updated successfully, returns updated cart")
    @ApiResponse(responseCode = "404", description = "Cart or menu item not found in cart")
    @PutMapping("/items/{menuItemId}")
    public ResponseEntity<CartResponse> updateCartItem(
            @Parameter(description = "ID of the user") @PathVariable("userId") String userId, // Explicitly named
            @Parameter(description = "ID of the menu item to update") @PathVariable("menuItemId") Long menuItemId, // Explicitly named
            @Valid @RequestBody UpdateCartItemRequest updateRequest) {
        CartResponse cartResponse = cartService.updateCartItem(userId, menuItemId, updateRequest);
        return ResponseEntity.ok(cartResponse);
    }

    @Operation(summary = "Remove an item from the cart")
    @ApiResponse(responseCode = "200", description = "Item removed successfully, returns updated cart")
    @ApiResponse(responseCode = "404", description = "Cart or menu item not found in cart")
    @DeleteMapping("/items/{menuItemId}")
    public ResponseEntity<CartResponse> removeCartItem(
            @Parameter(description = "ID of the user") @PathVariable("userId") String userId, // Explicitly named
            @Parameter(description = "ID of the menu item to remove") @PathVariable("menuItemId") Long menuItemId) { // Explicitly named
        CartResponse cartResponse = cartService.removeCartItem(userId, menuItemId);
        return ResponseEntity.ok(cartResponse);
    }

    @Operation(summary = "Clear all items from the user's cart")
    @ApiResponse(responseCode = "204", description = "Cart cleared successfully")
    @DeleteMapping
    public ResponseEntity<Void> clearCart(
            @Parameter(description = "ID of the user whose cart is being cleared") @PathVariable("userId") String userId) { // Explicitly named
        cartService.clearCart(userId);
        return ResponseEntity.noContent().build();
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/controller/OrderController.java ===
// File: backend/order/src/main/java/com/multirestaurantplatform/order/controller/OrderController.java
package com.multirestaurantplatform.order.controller;

import com.multirestaurantplatform.order.dto.OrderResponse;
import com.multirestaurantplatform.order.model.Order;
import com.multirestaurantplatform.order.service.OrderService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1") // Adjusted base path for user-specific cart endpoint
@RequiredArgsConstructor
@Tag(name = "Order Management", description = "APIs for managing customer orders and their lifecycle.")
@SecurityRequirement(name = "bearerAuth")
public class OrderController {

    private static final Logger LOGGER = LoggerFactory.getLogger(OrderController.class);
    private final OrderService orderService;

    // Endpoint to place an order from a user's cart
    @PostMapping("/users/{userId}/orders/place-from-cart")
    // CUSTOMER can place for their own userId. ADMIN can place for any userId.
    // userId here is expected to be the username for consistency with CartService.
    @PreAuthorize("hasRole('ADMIN') or (hasRole('CUSTOMER') and #userId == principal.username)")
    @Operation(summary = "Place an order from user's cart",
            description = "Creates a new order from the specified user's current shopping cart. " +
                    "The authenticated user must be the owner of the cart or an ADMIN. " +
                    "The cart will be cleared upon successful order placement.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Order placed successfully",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = OrderResponse.class))),
                    @ApiResponse(responseCode = "400", description = "Invalid request (e.g., cart empty, cart not associated with restaurant)"),
                    @ApiResponse(responseCode = "401", description = "Unauthorized - JWT token is missing or invalid"),
                    @ApiResponse(responseCode = "403", description = "Forbidden - User not authorized to place order for this cart"),
                    @ApiResponse(responseCode = "404", description = "User or Cart not found")
            })
    public ResponseEntity<OrderResponse> placeOrderFromCart(
            @Parameter(description = "Username of the user whose cart is to be converted into an order.") @PathVariable String userId,
            @Parameter(hidden = true) @AuthenticationPrincipal UserDetails principal) {
        // Note: If userId is a numeric ID, the @PreAuthorize and service logic would need adjustment.
        // Assuming userId is username here.
        LOGGER.info("API call to place order from cart for user: {} by principal: {}", userId, principal.getUsername());
        Order placedOrder = orderService.placeOrderFromCart(userId, principal);
        OrderResponse responseDto = OrderResponse.fromEntity(placedOrder);
        LOGGER.info("Order ID: {} placed successfully from cart for user: {}", responseDto.getId(), userId);
        return new ResponseEntity<>(responseDto, HttpStatus.CREATED);
    }


    // --- Existing Order Status Transition Endpoints ---
    @PutMapping("/orders/{orderId}/confirm")
    @PreAuthorize("hasRole('RESTAURANT_ADMIN')")
    @Operation(summary = "Confirm an order")
    public ResponseEntity<OrderResponse> confirmOrder(
            @Parameter(description = "ID of the order to be confirmed") @PathVariable Long orderId,
            @Parameter(hidden = true) @AuthenticationPrincipal UserDetails userDetails) {
        LOGGER.info("API call to confirm order ID: {} by user: {}", orderId, userDetails.getUsername());
        Order confirmedOrder = orderService.confirmOrder(orderId, userDetails);
        return ResponseEntity.ok(OrderResponse.fromEntity(confirmedOrder));
    }

    @PutMapping("/orders/{orderId}/prepare")
    @PreAuthorize("hasRole('RESTAURANT_ADMIN')")
    @Operation(summary = "Mark order as preparing")
    public ResponseEntity<OrderResponse> markAsPreparing(
            @Parameter(description = "ID of the order to be marked as preparing") @PathVariable Long orderId,
            @Parameter(hidden = true) @AuthenticationPrincipal UserDetails userDetails) {
        LOGGER.info("API call to mark order ID: {} as PREPARING by user: {}", orderId, userDetails.getUsername());
        Order preparingOrder = orderService.markAsPreparing(orderId, userDetails);
        return ResponseEntity.ok(OrderResponse.fromEntity(preparingOrder));
    }

    @PutMapping("/orders/{orderId}/ready-for-pickup")
    @PreAuthorize("hasRole('RESTAURANT_ADMIN')")
    @Operation(summary = "Mark order as ready for pickup")
    public ResponseEntity<OrderResponse> markAsReadyForPickup(
            @Parameter(description = "ID of the order to be marked as ready for pickup") @PathVariable Long orderId,
            @Parameter(hidden = true) @AuthenticationPrincipal UserDetails userDetails) {
        LOGGER.info("API call to mark order ID: {} as READY_FOR_PICKUP by user: {}", orderId, userDetails.getUsername());
        Order readyOrder = orderService.markAsReadyForPickup(orderId, userDetails);
        return ResponseEntity.ok(OrderResponse.fromEntity(readyOrder));
    }

    @PutMapping("/orders/{orderId}/picked-up")
    @PreAuthorize("hasRole('RESTAURANT_ADMIN')")
    @Operation(summary = "Mark order as picked up (Delivered)")
    public ResponseEntity<OrderResponse> markAsPickedUp(
            @Parameter(description = "ID of the order to be marked as picked up") @PathVariable Long orderId,
            @Parameter(hidden = true) @AuthenticationPrincipal UserDetails userDetails) {
        LOGGER.info("API call to mark order ID: {} as DELIVERED (picked up) by user: {}", orderId, userDetails.getUsername());
        Order pickedUpOrder = orderService.markAsPickedUp(orderId, userDetails);
        return ResponseEntity.ok(OrderResponse.fromEntity(pickedUpOrder));
    }

    @PutMapping("/orders/{orderId}/out-for-delivery")
    @PreAuthorize("hasRole('RESTAURANT_ADMIN')")
    @Operation(summary = "Mark order as out for delivery")
    public ResponseEntity<OrderResponse> markAsOutForDelivery(
            @Parameter(description = "ID of the order to be marked as out for delivery") @PathVariable Long orderId,
            @Parameter(hidden = true) @AuthenticationPrincipal UserDetails userDetails) {
        LOGGER.info("API call to mark order ID: {} as OUT_FOR_DELIVERY by user: {}", orderId, userDetails.getUsername());
        Order outForDeliveryOrder = orderService.markAsOutForDelivery(orderId, userDetails);
        return ResponseEntity.ok(OrderResponse.fromEntity(outForDeliveryOrder));
    }

    @PutMapping("/orders/{orderId}/delivery-completed")
    @PreAuthorize("hasRole('RESTAURANT_ADMIN')")
    @Operation(summary = "Mark order delivery as completed (Delivered)")
    public ResponseEntity<OrderResponse> completeDelivery(
            @Parameter(description = "ID of the order whose delivery is completed") @PathVariable Long orderId,
            @Parameter(hidden = true) @AuthenticationPrincipal UserDetails userDetails) {
        LOGGER.info("API call to complete delivery for order ID: {} by user: {}", orderId, userDetails.getUsername());
        Order deliveredOrder = orderService.completeDelivery(orderId, userDetails);
        return ResponseEntity.ok(OrderResponse.fromEntity(deliveredOrder));
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/model/Order.java ===
// File: backend/order/src/main/java/com/multirestaurantplatform/order/model/Order.java
package com.multirestaurantplatform.order.model;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Entity
@Table(name = "orders") // "order" is a reserved keyword in SQL, so "orders" is safer
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long customerId; // Assuming Customer entity is managed elsewhere

    @Column(nullable = false)
    private Long restaurantId; // Assuming Restaurant entity is managed elsewhere

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<OrderItem> orderItems = new ArrayList<>();

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OrderStatus status;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal totalPrice;

    // Delivery Address Details
    @Column(length = 255)
    private String deliveryAddressLine1;

    @Column(length = 255)
    private String deliveryAddressLine2;

    @Column(length = 100)
    private String deliveryCity;

    @Column(length = 100)
    private String deliveryState; // Or province

    @Column(length = 20)
    private String deliveryPostalCode;

    @Column(length = 100)
    private String deliveryCountry;

    @Column(length = 20)
    private String customerContactNumber; // For delivery purposes

    @Column(length = 500)
    private String specialInstructions;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    // Timestamps for status changes - can be expanded
    private LocalDateTime placedAt;
    private LocalDateTime confirmedAt;
    private LocalDateTime preparingAt;
    private LocalDateTime readyAt; // Ready for pickup or before out for delivery
    private LocalDateTime outForDeliveryAt; // New field
    private LocalDateTime deliveredAt;
    private LocalDateTime cancelledAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        // Note: placedAt is now set explicitly when status becomes PLACED in setStatus
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Constructors
    public Order() {
    }

    // Getters and Setters

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getCustomerId() {
        return customerId;
    }

    public void setCustomerId(Long customerId) {
        this.customerId = customerId;
    }

    public Long getRestaurantId() {
        return restaurantId;
    }

    public void setRestaurantId(Long restaurantId) {
        this.restaurantId = restaurantId;
    }

    public List<OrderItem> getOrderItems() {
        return orderItems;
    }

    public void setOrderItems(List<OrderItem> orderItems) {
        this.orderItems = orderItems;
        // Ensure bidirectional consistency
        if (orderItems != null) {
            for (OrderItem item : orderItems) {
                item.setOrder(this);
            }
        }
    }

    public void addOrderItem(OrderItem item) {
        if (item != null) {
            orderItems.add(item);
            item.setOrder(this);
        }
    }

    public void removeOrderItem(OrderItem item) {
        if (item != null) {
            orderItems.remove(item);
            item.setOrder(null);
        }
    }

    public OrderStatus getStatus() {
        return status;
    }

    public void setStatus(OrderStatus status) {
        this.status = status;
        // Update corresponding timestamp when status changes
        LocalDateTime now = LocalDateTime.now();
        switch (status) {
            case PLACED:
                this.placedAt = now;
                break;
            case CONFIRMED:
                this.confirmedAt = now;
                break;
            case PREPARING:
                this.preparingAt = now;
                break;
            case READY_FOR_PICKUP:
                this.readyAt = now; // Common 'ready' timestamp
                break;
            case OUT_FOR_DELIVERY:
                this.readyAt = (this.readyAt == null && this.preparingAt != null) ? now : this.readyAt; // If not already set as ready, mark as ready now
                this.outForDeliveryAt = now; // Specific timestamp for going out for delivery
                break;
            case DELIVERED:
                this.deliveredAt = now;
                break;
            case CANCELLED_BY_USER:
            case CANCELLED_BY_RESTAURANT:
            case FAILED: // Added FAILED case based on your OrderStatus enum
                this.cancelledAt = now; // Or a specific 'failedAt' if needed
                break;
            default:
                // Potentially log an unhandled status or do nothing
                break;
        }
    }

    public BigDecimal getTotalPrice() {
        return totalPrice;
    }

    public void setTotalPrice(BigDecimal totalPrice) {
        this.totalPrice = totalPrice;
    }

    public String getDeliveryAddressLine1() {
        return deliveryAddressLine1;
    }

    public void setDeliveryAddressLine1(String deliveryAddressLine1) {
        this.deliveryAddressLine1 = deliveryAddressLine1;
    }

    public String getDeliveryAddressLine2() {
        return deliveryAddressLine2;
    }

    public void setDeliveryAddressLine2(String deliveryAddressLine2) {
        this.deliveryAddressLine2 = deliveryAddressLine2;
    }

    public String getDeliveryCity() {
        return deliveryCity;
    }

    public void setDeliveryCity(String deliveryCity) {
        this.deliveryCity = deliveryCity;
    }

    public String getDeliveryState() {
        return deliveryState;
    }

    public void setDeliveryState(String deliveryState) {
        this.deliveryState = deliveryState;
    }

    public String getDeliveryPostalCode() {
        return deliveryPostalCode;
    }

    public void setDeliveryPostalCode(String deliveryPostalCode) {
        this.deliveryPostalCode = deliveryPostalCode;
    }

    public String getDeliveryCountry() {
        return deliveryCountry;
    }

    public void setDeliveryCountry(String deliveryCountry) {
        this.deliveryCountry = deliveryCountry;
    }

    public String getCustomerContactNumber() {
        return customerContactNumber;
    }

    public void setCustomerContactNumber(String customerContactNumber) {
        this.customerContactNumber = customerContactNumber;
    }

    public String getSpecialInstructions() {
        return specialInstructions;
    }

    public void setSpecialInstructions(String specialInstructions) {
        this.specialInstructions = specialInstructions;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public LocalDateTime getPlacedAt() {
        return placedAt;
    }

    public void setPlacedAt(LocalDateTime placedAt) {
        this.placedAt = placedAt;
    }

    public LocalDateTime getConfirmedAt() {
        return confirmedAt;
    }

    public void setConfirmedAt(LocalDateTime confirmedAt) {
        this.confirmedAt = confirmedAt;
    }

    public LocalDateTime getPreparingAt() {
        return preparingAt;
    }

    public void setPreparingAt(LocalDateTime preparingAt) {
        this.preparingAt = preparingAt;
    }

    public LocalDateTime getReadyAt() {
        return readyAt;
    }

    public void setReadyAt(LocalDateTime readyAt) {
        this.readyAt = readyAt;
    }

    public LocalDateTime getOutForDeliveryAt() {
        return outForDeliveryAt;
    }

    public void setOutForDeliveryAt(LocalDateTime outForDeliveryAt) {
        this.outForDeliveryAt = outForDeliveryAt;
    }

    public LocalDateTime getDeliveredAt() {
        return deliveredAt;
    }

    public void setDeliveredAt(LocalDateTime deliveredAt) {
        this.deliveredAt = deliveredAt;
    }

    public LocalDateTime getCancelledAt() {
        return cancelledAt;
    }

    public void setCancelledAt(LocalDateTime cancelledAt) {
        this.cancelledAt = cancelledAt;
    }

    // equals, hashCode, toString

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Order order = (Order) o;
        return Objects.equals(id, order.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "Order{" +
                "id=" + id +
                ", customerId=" + customerId +
                ", restaurantId=" + restaurantId +
                ", status=" + status +
                ", totalPrice=" + totalPrice +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/model/OrderItem.java ===
package com.multirestaurantplatform.order.model;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.util.Objects;

@Entity
@Table(name = "order_items")
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Long menuItemId; // Assuming MenuItem entity is managed elsewhere (e.g., Menu module)

    @Column(nullable = false, length = 255)
    private String menuItemName; // Denormalized for easier display, can be fetched if needed

    @Column(nullable = false)
    private Integer quantity;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice; // Price of a single unit at the time of order

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal itemTotalPrice; // quantity * unitPrice

    // Optional: store selected options if menu items can be customized
    @Column(length = 1000) // Store as JSON string or use a separate table for complex options
    private String selectedOptions;


    // Constructors
    public OrderItem() {
    }

    // Getters and Setters

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Order getOrder() {
        return order;
    }

    public void setOrder(Order order) {
        this.order = order;
    }

    public Long getMenuItemId() {
        return menuItemId;
    }

    public void setMenuItemId(Long menuItemId) {
        this.menuItemId = menuItemId;
    }

    public String getMenuItemName() {
        return menuItemName;
    }

    public void setMenuItemName(String menuItemName) {
        this.menuItemName = menuItemName;
    }

    public Integer getQuantity() {
        return quantity;
    }

    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
    }

    public BigDecimal getUnitPrice() {
        return unitPrice;
    }

    public void setUnitPrice(BigDecimal unitPrice) {
        this.unitPrice = unitPrice;
    }

    public BigDecimal getItemTotalPrice() {
        return itemTotalPrice;
    }

    public void setItemTotalPrice(BigDecimal itemTotalPrice) {
        this.itemTotalPrice = itemTotalPrice;
    }

    public String getSelectedOptions() {
        return selectedOptions;
    }

    public void setSelectedOptions(String selectedOptions) {
        this.selectedOptions = selectedOptions;
    }

    // equals, hashCode, toString

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OrderItem orderItem = (OrderItem) o;
        return Objects.equals(id, orderItem.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "OrderItem{" +
                "id=" + id +
                ", menuItemId=" + menuItemId +
                ", menuItemName='" + menuItemName + '\'' +
                ", quantity=" + quantity +
                ", unitPrice=" + unitPrice +
                ", itemTotalPrice=" + itemTotalPrice +
                '}';
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/model/OrderStatus.java ===
package com.multirestaurantplatform.order.model;

public enum OrderStatus {
    PENDING_PAYMENT, // Optional: If payment is deferred
    PLACED,          // Initial status after successful order creation and payment
    CONFIRMED,       // Restaurant confirms they have received and accepted the order
    PREPARING,       // Restaurant is preparing the order
    READY_FOR_PICKUP,// Order is ready for pickup (if applicable)
    OUT_FOR_DELIVERY, // Order is out for delivery (if applicable)
    DELIVERED,       // Order has been successfully delivered
    CANCELLED_BY_USER,
    CANCELLED_BY_RESTAURANT,
    FAILED           // If order processing failed for some reason (e.g., payment failed post-placement)
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/model/cart/Cart.java ===
package com.multirestaurantplatform.order.model.cart;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class Cart {
    private String userId; // Or session ID
    private Long restaurantId; // A cart is typically associated with a single restaurant
    private String restaurantName; // For display convenience
    private List<CartItem> items;
    private BigDecimal cartTotalPrice;

    public Cart(String userId) {
        this.userId = userId;
        this.items = new ArrayList<>();
        this.cartTotalPrice = BigDecimal.ZERO;
    }

    public Cart(String userId, Long restaurantId, String restaurantName) {
        this.userId = userId;
        this.restaurantId = restaurantId;
        this.restaurantName = restaurantName;
        this.items = new ArrayList<>();
        this.cartTotalPrice = BigDecimal.ZERO;
    }


    // Getters and Setters
    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public Long getRestaurantId() {
        return restaurantId;
    }

    public void setRestaurantId(Long restaurantId) {
        this.restaurantId = restaurantId;
    }

    public String getRestaurantName() {
        return restaurantName;
    }

    public void setRestaurantName(String restaurantName) {
        this.restaurantName = restaurantName;
    }

    public List<CartItem> getItems() {
        return items;
    }

    public void setItems(List<CartItem> items) {
        this.items = items;
        recalculateCartTotalPrice();
    }

    public BigDecimal getCartTotalPrice() {
        return cartTotalPrice;
    }

    // Internal method to recalculate total
    public void recalculateCartTotalPrice() {
        this.cartTotalPrice = items.stream()
                                   .map(CartItem::getTotalPrice)
                                   .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cart cart = (Cart) o;
        return Objects.equals(userId, cart.userId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId);
    }

    @Override
    public String toString() {
        return "Cart{" +
                "userId='" + userId + '\'' +
                ", restaurantId=" + restaurantId +
                ", restaurantName='" + restaurantName + '\'' +
                ", itemsCount=" + (items != null ? items.size() : 0) +
                ", cartTotalPrice=" + cartTotalPrice +
                '}';
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/model/cart/CartItem.java ===
package com.multirestaurantplatform.order.model.cart;

import java.math.BigDecimal;
import java.util.Objects;

public class CartItem {
    private Long menuItemId;
    private String menuItemName;
    private Integer quantity;
    private BigDecimal unitPrice;
    private BigDecimal totalPrice;
    // Potentially add restaurantId if items from different restaurants could be in a "wishlist"
    // but for an active order cart, items are usually from one restaurant.

    public CartItem() {
    }

    public CartItem(Long menuItemId, String menuItemName, Integer quantity, BigDecimal unitPrice) {
        this.menuItemId = menuItemId;
        this.menuItemName = menuItemName;
        this.quantity = quantity;
        this.unitPrice = unitPrice;
        this.totalPrice = unitPrice.multiply(BigDecimal.valueOf(quantity));
    }

    // Getters and Setters
    public Long getMenuItemId() {
        return menuItemId;
    }

    public void setMenuItemId(Long menuItemId) {
        this.menuItemId = menuItemId;
    }

    public String getMenuItemName() {
        return menuItemName;
    }

    public void setMenuItemName(String menuItemName) {
        this.menuItemName = menuItemName;
    }

    public Integer getQuantity() {
        return quantity;
    }

    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
        // Recalculate total price if unitPrice is set
        if (this.unitPrice != null) {
            this.totalPrice = this.unitPrice.multiply(BigDecimal.valueOf(quantity));
        }
    }

    public BigDecimal getUnitPrice() {
        return unitPrice;
    }

    public void setUnitPrice(BigDecimal unitPrice) {
        this.unitPrice = unitPrice;
        // Recalculate total price if quantity is set
        if (this.quantity != null) {
            this.totalPrice = this.unitPrice.multiply(BigDecimal.valueOf(this.quantity));
        }
    }

    public BigDecimal getTotalPrice() {
        return totalPrice;
    }

    public void setTotalPrice(BigDecimal totalPrice) {
        this.totalPrice = totalPrice;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CartItem cartItem = (CartItem) o;
        return Objects.equals(menuItemId, cartItem.menuItemId); // Typically, a cart item is unique by its menuItemId
    }

    @Override
    public int hashCode() {
        return Objects.hash(menuItemId);
    }

    @Override
    public String toString() {
        return "CartItem{" +
                "menuItemId=" + menuItemId +
                ", menuItemName='" + menuItemName + '\'' +
                ", quantity=" + quantity +
                ", unitPrice=" + unitPrice +
                ", totalPrice=" + totalPrice +
                '}';
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/service/CartService.java ===
package com.multirestaurantplatform.order.service;

import com.multirestaurantplatform.order.dto.AddItemToCartRequest;
import com.multirestaurantplatform.order.dto.CartResponse;
import com.multirestaurantplatform.order.dto.UpdateCartItemRequest;

public interface CartService {
    CartResponse addItemToCart(String userId, AddItemToCartRequest addItemRequest);
    CartResponse getCart(String userId);
    CartResponse updateCartItem(String userId, Long menuItemId, UpdateCartItemRequest updateRequest);
    CartResponse removeCartItem(String userId, Long menuItemId);
    void clearCart(String userId);
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/service/InMemoryCartServiceImpl.java ===
package com.multirestaurantplatform.order.service;

import com.multirestaurantplatform.order.dto.*;
import com.multirestaurantplatform.order.exception.CartNotFoundException;
import com.multirestaurantplatform.order.exception.CartUpdateException;
import com.multirestaurantplatform.order.exception.MenuItemNotFoundInCartException;
import com.multirestaurantplatform.order.model.cart.Cart;
import com.multirestaurantplatform.order.model.cart.CartItem;
import com.multirestaurantplatform.order.service.client.MenuItemDetailsDto;
import com.multirestaurantplatform.order.service.client.MenuServiceClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
public class InMemoryCartServiceImpl implements CartService {

    private static final Logger logger = LoggerFactory.getLogger(InMemoryCartServiceImpl.class);
    private final Map<String, Cart> userCarts = new ConcurrentHashMap<>();
    private final MenuServiceClient menuServiceClient; // To fetch item details

    @Autowired
    public InMemoryCartServiceImpl(MenuServiceClient menuServiceClient) {
        this.menuServiceClient = menuServiceClient;
        // Initialize with a Stub implementation for now if a real one isn't available
        // This will be replaced by a proper client (e.g. Feign client or direct service call)
        logger.info("InMemoryCartServiceImpl initialized. MenuServiceClient type: {}",
            menuServiceClient.getClass().getSimpleName());
    }

    @Override
    public CartResponse addItemToCart(String userId, AddItemToCartRequest addItemRequest) {
        MenuItemDetailsDto itemDetails = menuServiceClient
                .getMenuItemDetails(addItemRequest.getMenuItemId(), addItemRequest.getRestaurantId())
                .orElseThrow(() -> new CartUpdateException("Menu item " + addItemRequest.getMenuItemId() + " not found or unavailable."));

        if (!itemDetails.isAvailable()) {
            throw new CartUpdateException("Menu item " + itemDetails.getName() + " is currently unavailable.");
        }
        
        if (!itemDetails.getRestaurantId().equals(addItemRequest.getRestaurantId())) {
            // This check might be redundant if getMenuItemDetails already uses restaurantId for lookup scope
            throw new CartUpdateException("Menu item " + itemDetails.getName() + " does not belong to restaurant " + addItemRequest.getRestaurantId());
        }

        Cart cart = userCarts.computeIfAbsent(userId, k -> new Cart(userId, itemDetails.getRestaurantId(), itemDetails.getRestaurantName()));

        // Check if item is from a different restaurant than the current cart
        if (!cart.getRestaurantId().equals(itemDetails.getRestaurantId())) {
            // Policy: Clear cart if adding from a new restaurant, or throw error.
            // For now, let's clear and start a new cart.
            logger.info("User {} adding item from new restaurant {}. Clearing old cart from restaurant {}.",
                    userId, itemDetails.getRestaurantName(), cart.getRestaurantName());
            cart = new Cart(userId, itemDetails.getRestaurantId(), itemDetails.getRestaurantName());
            userCarts.put(userId, cart);
        }


        Optional<CartItem> existingItemOpt = cart.getItems().stream()
                .filter(ci -> ci.getMenuItemId().equals(addItemRequest.getMenuItemId()))
                .findFirst();

        if (existingItemOpt.isPresent()) {
            CartItem existingItem = existingItemOpt.get();
            existingItem.setQuantity(existingItem.getQuantity() + addItemRequest.getQuantity());
        } else {
            CartItem newItem = new CartItem(
                    itemDetails.getId(),
                    itemDetails.getName(),
                    addItemRequest.getQuantity(),
                    itemDetails.getPrice()
            );
            cart.getItems().add(newItem);
        }
        cart.recalculateCartTotalPrice();
        return mapCartToResponse(cart);
    }

    @Override
    public CartResponse getCart(String userId) {
        Cart cart = userCarts.get(userId);
        if (cart == null) {
            // Return an empty cart response instead of throwing an error for GET
            return new CartResponse(userId, null, null, List.of(), java.math.BigDecimal.ZERO);
        }
        return mapCartToResponse(cart);
    }

    @Override
    public CartResponse updateCartItem(String userId, Long menuItemId, UpdateCartItemRequest updateRequest) {
        Cart cart = userCarts.get(userId);
        if (cart == null) {
            throw new CartNotFoundException("Cart not found for user " + userId);
        }

        CartItem itemToUpdate = cart.getItems().stream()
                .filter(ci -> ci.getMenuItemId().equals(menuItemId))
                .findFirst()
                .orElseThrow(() -> new MenuItemNotFoundInCartException("Menu item " + menuItemId + " not found in cart."));

        itemToUpdate.setQuantity(updateRequest.getQuantity());
        cart.recalculateCartTotalPrice();
        return mapCartToResponse(cart);
    }

    @Override
    public CartResponse removeCartItem(String userId, Long menuItemId) {
        Cart cart = userCarts.get(userId);
        if (cart == null) {
            throw new CartNotFoundException("Cart not found for user " + userId);
        }

        boolean removed = cart.getItems().removeIf(ci -> ci.getMenuItemId().equals(menuItemId));
        if (!removed) {
            throw new MenuItemNotFoundInCartException("Menu item " + menuItemId + " not found in cart for removal.");
        }
        
        // If cart becomes empty, we could remove the cart itself from userCarts or keep it as an empty cart.
        // Keeping it is simpler for now. If items empty, restaurantId might become irrelevant.
        if (cart.getItems().isEmpty()) {
            cart.setRestaurantId(null);
            cart.setRestaurantName(null);
        }

        cart.recalculateCartTotalPrice();
        return mapCartToResponse(cart);
    }

    @Override
    public void clearCart(String userId) {
        Cart cart = userCarts.remove(userId);
         if (cart == null) {
            // Optionally, you could throw CartNotFoundException or just log
            logger.info("Attempted to clear a non-existent cart for user {}", userId);
            // To ensure idempotency or avoid error for clearing non-existent cart:
            // throw new CartNotFoundException("Cart not found for user " + userId + " to clear.");
        } else {
            logger.info("Cart cleared for user {}", userId);
        }
    }

    private CartResponse mapCartToResponse(Cart cart) {
        List<CartItemResponse> itemResponses = cart.getItems().stream()
                .map(ci -> new CartItemResponse(
                        ci.getMenuItemId(),
                        ci.getMenuItemName(),
                        ci.getQuantity(),
                        ci.getUnitPrice(),
                        ci.getTotalPrice()))
                .collect(Collectors.toList());
        return new CartResponse(cart.getUserId(), cart.getRestaurantId(), cart.getRestaurantName(), itemResponses, cart.getCartTotalPrice());
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/service/OrderService.java ===
// File: backend/order/src/main/java/com/multirestaurantplatform/order/service/OrderService.java
package com.multirestaurantplatform.order.service;

import com.multirestaurantplatform.order.model.Order;
import org.springframework.security.core.userdetails.UserDetails;

public interface OrderService {

    /**
     * Creates a new order from the user's current shopping cart.
     * Sets the order status to PLACED and clears the cart.
     *
     * @param userId The ID of the user for whom the order is being placed.
     * This is typically the customer's ID.
     * @param principal The UserDetails of the authenticated user performing the action.
     * Used for authorization (e.g., customer placing their own order, or admin placing for a user).
     * @return The newly created Order entity.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the user or their cart is not found, or if cart items refer to non-existent entities.
     * @throws com.multirestaurantplatform.order.exception.IllegalOrderStateException if the cart is empty or in an invalid state for order placement.
     * @throws org.springframework.security.access.AccessDeniedException if the principal is not authorized to place an order for the given userId.
     * @throws com.multirestaurantplatform.order.exception.CartUpdateException if cart items are invalid (e.g. from MenuServiceClient).
     */
    Order placeOrderFromCart(String userId, UserDetails principal /*, PlaceOrderRequestDto placeOrderRequestDto if needed for delivery address etc. */);

    Order confirmOrder(Long orderId, UserDetails restaurantAdminPrincipal);
    Order markAsPreparing(Long orderId, UserDetails restaurantAdminPrincipal);
    Order markAsReadyForPickup(Long orderId, UserDetails restaurantAdminPrincipal);
    Order markAsPickedUp(Long orderId, UserDetails restaurantAdminPrincipal);
    Order markAsOutForDelivery(Long orderId, UserDetails principal);
    Order completeDelivery(Long orderId, UserDetails principal);
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/service/impl/OrderServiceImpl.java ===
// File: backend/order/src/main/java/com/multirestaurantplatform/order/service/impl/OrderServiceImpl.java
package com.multirestaurantplatform.order.service.impl;

import com.multirestaurantplatform.common.exception.ResourceNotFoundException;
import com.multirestaurantplatform.order.dto.CartItemResponse;
import com.multirestaurantplatform.order.dto.CartResponse;
import com.multirestaurantplatform.order.exception.IllegalOrderStateException;
import com.multirestaurantplatform.order.model.Order;
import com.multirestaurantplatform.order.model.OrderItem;
import com.multirestaurantplatform.order.model.OrderStatus;
import com.multirestaurantplatform.order.repository.OrderRepository;
import com.multirestaurantplatform.order.service.CartService; // Import CartService
import com.multirestaurantplatform.order.service.OrderService;
import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.repository.RestaurantRepository;
import com.multirestaurantplatform.security.model.Role; // Import Role
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private static final Logger LOGGER = LoggerFactory.getLogger(OrderServiceImpl.class);

    private final OrderRepository orderRepository;
    private final RestaurantRepository restaurantRepository;
    private final UserRepository userRepository;
    private final CartService cartService; // Inject CartService

    @Override
    @Transactional
    public Order placeOrderFromCart(String userIdFromPath, UserDetails principal) {
        LOGGER.info("Attempting to place order from cart for user ID path: {} by principal: {}", userIdFromPath, principal.getUsername());

        // 1. Authorize the action
        User customer = userRepository.findByUsername(userIdFromPath) // Assuming userIdFromPath is the username
                .orElseThrow(() -> new ResourceNotFoundException("User with username " + userIdFromPath + " not found."));

        boolean isAdmin = principal.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .anyMatch(auth -> auth.equals("ROLE_" + Role.ADMIN.name()));

        if (!isAdmin && !principal.getUsername().equals(customer.getUsername())) {
            LOGGER.warn("Authorization failed: Principal {} is not authorized to place order for user {}", principal.getUsername(), customer.getUsername());
            throw new AccessDeniedException("You are not authorized to place an order for this user.");
        }
        LOGGER.info("User {} authorized to place order for user ID path: {}", principal.getUsername(), userIdFromPath);

        // 2. Retrieve the cart
        // The userId for cartService should be the actual username/identifier used by CartService
        CartResponse cartResponse = cartService.getCart(customer.getUsername()); // Use customer's username

        // 3. Validate the cart
        if (cartResponse == null || CollectionUtils.isEmpty(cartResponse.getItems())) {
            LOGGER.warn("Order placement failed: Cart for user {} is empty or not found.", customer.getUsername());
            throw new IllegalOrderStateException("Cannot place order: Cart is empty.");
        }
        if (cartResponse.getRestaurantId() == null) {
            LOGGER.warn("Order placement failed: Cart for user {} does not have a restaurant associated.", customer.getUsername());
            throw new IllegalOrderStateException("Cannot place order: Cart is not associated with a restaurant.");
        }

        // 4. Create new Order entity
        Order newOrder = new Order();
        newOrder.setCustomerId(customer.getId());
        newOrder.setRestaurantId(cartResponse.getRestaurantId());
        newOrder.setTotalPrice(cartResponse.getCartTotalPrice() != null ? cartResponse.getCartTotalPrice() : BigDecimal.ZERO);
        newOrder.setStatus(OrderStatus.PLACED);
        // newOrder.setPlacedAt(LocalDateTime.now()); // This is handled by setStatus
        // Delivery details can be set here if provided, or updated later. For now, they remain null.
        // newOrder.setDeliveryAddressLine1(...);

        // 5. Create OrderItem entities from cart items
        List<OrderItem> orderItems = new ArrayList<>();
        for (CartItemResponse cartItemDto : cartResponse.getItems()) {
            OrderItem orderItem = new OrderItem();
            orderItem.setMenuItemId(cartItemDto.getMenuItemId());
            orderItem.setMenuItemName(cartItemDto.getMenuItemName());
            orderItem.setQuantity(cartItemDto.getQuantity());
            orderItem.setUnitPrice(cartItemDto.getUnitPrice());
            orderItem.setItemTotalPrice(cartItemDto.getTotalPrice());
            // orderItem.setSelectedOptions(...); // If you have options
            newOrder.addOrderItem(orderItem); // This also sets orderItem.setOrder(newOrder)
        }
        // newOrder.setOrderItems(orderItems); // addOrderItem handles this

        // 6. Save the order (OrderItems will be cascaded)
        Order savedOrder = orderRepository.save(newOrder);
        LOGGER.info("Order ID: {} placed successfully for user: {} by principal: {}", savedOrder.getId(), customer.getUsername(), principal.getUsername());

        // 7. Clear the cart
        try {
            cartService.clearCart(customer.getUsername());
            LOGGER.info("Cart cleared for user: {} after order placement.", customer.getUsername());
        } catch (Exception e) {
            // Log the error but don't let it fail the order placement transaction.
            // Cart clearing is a secondary concern here.
            LOGGER.error("Failed to clear cart for user {} after order placement. Order ID: {}. Error: {}",
                    customer.getUsername(), savedOrder.getId(), e.getMessage());
        }

        return savedOrder;
    }


    // ... other existing service methods (confirmOrder, markAsPreparing, etc.)
    @Override
    @Transactional
    public Order confirmOrder(Long orderId, UserDetails restaurantAdminPrincipal) {
        LOGGER.info("Attempting to confirm order with ID: {} by user: {}", orderId, restaurantAdminPrincipal.getUsername());
        Order order = findOrderByIdOrThrow(orderId);
        authorizeRestaurantAdminForOrder(order, restaurantAdminPrincipal);
        validateOrderStatus(order, OrderStatus.PLACED, "confirm");
        order.setStatus(OrderStatus.CONFIRMED);
        Order savedOrder = orderRepository.save(order);
        LOGGER.info("Order ID: {} confirmed successfully by user: {}", savedOrder.getId(), restaurantAdminPrincipal.getUsername());
        return savedOrder;
    }

    @Override
    @Transactional
    public Order markAsPreparing(Long orderId, UserDetails restaurantAdminPrincipal) {
        LOGGER.info("Attempting to mark order as PREPARING with ID: {} by user: {}", orderId, restaurantAdminPrincipal.getUsername());
        Order order = findOrderByIdOrThrow(orderId);
        authorizeRestaurantAdminForOrder(order, restaurantAdminPrincipal);
        validateOrderStatus(order, OrderStatus.CONFIRMED, "mark as preparing");
        order.setStatus(OrderStatus.PREPARING);
        Order savedOrder = orderRepository.save(order);
        LOGGER.info("Order ID: {} marked as PREPARING successfully by user: {}", savedOrder.getId(), restaurantAdminPrincipal.getUsername());
        return savedOrder;
    }

    @Override
    @Transactional
    public Order markAsReadyForPickup(Long orderId, UserDetails restaurantAdminPrincipal) {
        LOGGER.info("Attempting to mark order as READY_FOR_PICKUP with ID: {} by user: {}", orderId, restaurantAdminPrincipal.getUsername());
        Order order = findOrderByIdOrThrow(orderId);
        authorizeRestaurantAdminForOrder(order, restaurantAdminPrincipal);
        validateOrderStatus(order, OrderStatus.PREPARING, "mark as ready for pickup");
        order.setStatus(OrderStatus.READY_FOR_PICKUP);
        Order savedOrder = orderRepository.save(order);
        LOGGER.info("Order ID: {} marked as READY_FOR_PICKUP successfully by user: {}", savedOrder.getId(), restaurantAdminPrincipal.getUsername());
        return savedOrder;
    }

    @Override
    @Transactional
    public Order markAsPickedUp(Long orderId, UserDetails restaurantAdminPrincipal) {
        LOGGER.info("Attempting to mark order as DELIVERED (picked up) with ID: {} by user: {}", orderId, restaurantAdminPrincipal.getUsername());
        Order order = findOrderByIdOrThrow(orderId);
        authorizeRestaurantAdminForOrder(order, restaurantAdminPrincipal);
        validateOrderStatus(order, OrderStatus.READY_FOR_PICKUP, "mark as picked up");
        order.setStatus(OrderStatus.DELIVERED);
        Order savedOrder = orderRepository.save(order);
        LOGGER.info("Order ID: {} marked as DELIVERED (picked up) successfully by user: {}", savedOrder.getId(), restaurantAdminPrincipal.getUsername());
        return savedOrder;
    }

    @Override
    @Transactional
    public Order markAsOutForDelivery(Long orderId, UserDetails principal) {
        LOGGER.info("Attempting to mark order as OUT_FOR_DELIVERY with ID: {} by user: {}", orderId, principal.getUsername());
        Order order = findOrderByIdOrThrow(orderId);
        authorizeRestaurantAdminForOrder(order, principal);
        if (order.getStatus() != OrderStatus.READY_FOR_PICKUP && order.getStatus() != OrderStatus.PREPARING) {
            LOGGER.warn("Marking order as OUT_FOR_DELIVERY failed: Order ID {} is not in READY_FOR_PICKUP or PREPARING state. Current state: {}", orderId, order.getStatus());
            throw new IllegalOrderStateException(
                    "Order cannot be marked as out for delivery. Expected status READY_FOR_PICKUP or PREPARING, but was " + order.getStatus() + "."
            );
        }
        order.setStatus(OrderStatus.OUT_FOR_DELIVERY);
        Order savedOrder = orderRepository.save(order);
        LOGGER.info("Order ID: {} marked as OUT_FOR_DELIVERY successfully by user: {}", savedOrder.getId(), principal.getUsername());
        return savedOrder;
    }

    @Override
    @Transactional
    public Order completeDelivery(Long orderId, UserDetails principal) {
        LOGGER.info("Attempting to complete delivery for order ID: {} by user: {}", orderId, principal.getUsername());
        Order order = findOrderByIdOrThrow(orderId);
        authorizeRestaurantAdminForOrder(order, principal);
        validateOrderStatus(order, OrderStatus.OUT_FOR_DELIVERY, "complete delivery");
        order.setStatus(OrderStatus.DELIVERED);
        Order savedOrder = orderRepository.save(order);
        LOGGER.info("Order ID: {} marked as DELIVERED (delivery completed) successfully by user: {}", savedOrder.getId(), principal.getUsername());
        return savedOrder;
    }

    private Order findOrderByIdOrThrow(Long orderId) {
        return orderRepository.findById(orderId)
                .orElseThrow(() -> {
                    LOGGER.warn("Order operation failed: Order not found with ID: {}", orderId);
                    return new ResourceNotFoundException("Order not found with id: " + orderId);
                });
    }

    private void authorizeRestaurantAdminForOrder(Order order, UserDetails principal) {
        Long orderRestaurantId = order.getRestaurantId();
        if (orderRestaurantId == null) {
            LOGGER.error("Authorization failed: Order ID {} is not associated with any restaurant.", order.getId());
            throw new IllegalStateException("Order " + order.getId() + " has no associated restaurant ID.");
        }
        String principalUsername = principal.getUsername();
        User adminUser = userRepository.findByUsername(principalUsername)
                .orElseThrow(() -> {
                    LOGGER.warn("Authorization failed: User {} (from principal) not found in repository.", principalUsername);
                    return new UsernameNotFoundException("Authenticated user " + principalUsername + " not found in database.");
                });
        Restaurant restaurant = restaurantRepository.findById(orderRestaurantId)
                .orElseThrow(() -> {
                    LOGGER.warn("Restaurant ID {} (for order ID {}) not found during authorization.", orderRestaurantId, order.getId());
                    return new ResourceNotFoundException("Restaurant not found with ID: " + orderRestaurantId + " for order " + order.getId());
                });
        boolean isAuthorized = restaurant.getRestaurantAdmins().stream()
                .anyMatch(admin -> admin.getId().equals(adminUser.getId()));
        if (!isAuthorized) {
            LOGGER.warn("Authorization failed: User {} (ID: {}) is not an admin for restaurant ID {} (Order ID: {})",
                    principalUsername, adminUser.getId(), orderRestaurantId, order.getId());
            throw new AccessDeniedException("User " + principalUsername +
                    " is not authorized to manage orders for restaurant ID " + orderRestaurantId);
        }
        LOGGER.debug("User {} is authorized for restaurant ID {} of order ID {}",
                principalUsername, orderRestaurantId, order.getId());
    }

    private void validateOrderStatus(Order order, OrderStatus expectedStatus, String actionDescription) {
        if (order.getStatus() != expectedStatus) {
            String errorMessage = String.format(
                    "Order cannot be %s. Expected status %s, but was %s.",
                    actionDescription, expectedStatus, order.getStatus()
            );
            LOGGER.warn("Order state validation failed for order ID {}: {}", order.getId(), errorMessage);
            throw new IllegalOrderStateException(errorMessage);
        }
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/service/client/MenuItemDetailsDto.java ===
package com.multirestaurantplatform.order.service.client;

import java.math.BigDecimal;

public class MenuItemDetailsDto {
    private Long id;
    private String name;
    private BigDecimal price;
    private Long restaurantId;
    private String restaurantName; // Optional, but useful
    private boolean available;

    // Constructors, Getters, Setters
    public MenuItemDetailsDto() {}

    public MenuItemDetailsDto(Long id, String name, BigDecimal price, Long restaurantId, String restaurantName, boolean available) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.restaurantId = restaurantId;
        this.restaurantName = restaurantName;
        this.available = available;
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public BigDecimal getPrice() { return price; }
    public void setPrice(BigDecimal price) { this.price = price; }
    public Long getRestaurantId() { return restaurantId; }
    public void setRestaurantId(Long restaurantId) { this.restaurantId = restaurantId; }
    public String getRestaurantName() { return restaurantName; }
    public void setRestaurantName(String restaurantName) { this.restaurantName = restaurantName; }
    public boolean isAvailable() { return available; }
    public void setAvailable(boolean available) { this.available = available; }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/service/client/MenuServiceClient.java ===
package com.multirestaurantplatform.order.service.client;

import java.util.Optional;

public interface MenuServiceClient {
    /**
     * Fetches details of a menu item.
     * @param menuItemId The ID of the menu item.
     * @param restaurantId The ID of the restaurant (for context, though menuItemId might be globally unique or unique within restaurant).
     * @return Optional containing MenuItemDetailsDto if found and available, empty otherwise.
     */
    Optional<MenuItemDetailsDto> getMenuItemDetails(Long menuItemId, Long restaurantId);
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/service/client/StubMenuServiceClientImpl.java ===
package com.multirestaurantplatform.order.service.client;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component; // Or @Service
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

// This is a STUB implementation for development and testing of CartService.
// In a real application, this would be a Feign client or similar,
// or a direct call to another module's service.
@Component // Make it a Spring bean so CartService can autowire it
public class StubMenuServiceClientImpl implements MenuServiceClient {

    private static final Logger logger = LoggerFactory.getLogger(StubMenuServiceClientImpl.class);
    private final Map<Long, MenuItemDetailsDto> mockMenuDatabase = new HashMap<>();

    public StubMenuServiceClientImpl() {
        // Populate with some mock data
        // Restaurant 1
        mockMenuDatabase.put(101L, new MenuItemDetailsDto(101L, "Classic Burger", new BigDecimal("12.99"), 1L, "Burger Queen", true));
        mockMenuDatabase.put(102L, new MenuItemDetailsDto(102L, "Cheese Fries", new BigDecimal("5.50"), 1L, "Burger Queen", true));
        mockMenuDatabase.put(103L, new MenuItemDetailsDto(103L, "Milkshake", new BigDecimal("4.00"), 1L, "Burger Queen", false)); // Unavailable

        // Restaurant 2
        mockMenuDatabase.put(201L, new MenuItemDetailsDto(201L, "Margherita Pizza", new BigDecimal("15.00"), 2L, "Pizza Palace", true));
        mockMenuDatabase.put(202L, new MenuItemDetailsDto(202L, "Pepperoni Pizza", new BigDecimal("17.50"), 2L, "Pizza Palace", true));
        logger.info("StubMenuServiceClientImpl initialized with mock data.");
    }

    @Override
    public Optional<MenuItemDetailsDto> getMenuItemDetails(Long menuItemId, Long restaurantId) {
        logger.debug("StubMenuServiceClient: Fetching menuItemId: {}, restaurantId: {}", menuItemId, restaurantId);
        MenuItemDetailsDto item = mockMenuDatabase.get(menuItemId);
        if (item != null && item.getRestaurantId().equals(restaurantId)) {
            return Optional.of(item);
        }
        // If item exists but for wrong restaurant, it's effectively not found for this call context
        if (item != null && !item.getRestaurantId().equals(restaurantId)) {
             logger.warn("StubMenuServiceClient: Item {} found but belongs to restaurant {}, expected {}",
                menuItemId, item.getRestaurantId(), restaurantId);
        }
        return Optional.empty();
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/exception/CartNotFoundException.java ===
package com.multirestaurantplatform.order.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class CartNotFoundException extends RuntimeException {
    public CartNotFoundException(String message) {
        super(message);
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/exception/CartUpdateException.java ===
package com.multirestaurantplatform.order.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class CartUpdateException extends RuntimeException {
    public CartUpdateException(String message) {
        super(message);
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/exception/IllegalOrderStateException.java ===
package com.multirestaurantplatform.order.exception;

public class IllegalOrderStateException extends RuntimeException {
    public IllegalOrderStateException(String message) {
        super(message);
    }

    public IllegalOrderStateException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/order/src/main/java/com/multirestaurantplatform/order/exception/MenuItemNotFoundInCartException.java ===
package com.multirestaurantplatform.order.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class MenuItemNotFoundInCartException extends RuntimeException {
    public MenuItemNotFoundInCartException(String message) {
        super(message);
    }
}
=== backend/restaurant/build.gradle ===
plugins {
    id 'java-library'
}

description = 'The restaurant module'

dependencies {
    // Dependency on the common module (for BaseEntity, etc.)
    implementation project(':backend:common')

    // Dependency on the security module (for User entity)
    implementation project(':backend:security')

    // REMOVED: implementation project(':backend:menu') // This line caused the circular dependency

    // Spring Data JPA (version managed by Spring Boot BOM in root project)
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    implementation 'org.springframework.boot:spring-boot-starter-validation'


    // Lombok is managed in the root build.gradle

    testImplementation 'org.springframework.boot:spring-boot-starter-test' // Includes JUnit 5, Mockito, AssertJ, etc.
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/CreateRestaurantRequestDto.java ===
package com.multirestaurantplatform.restaurant.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CreateRestaurantRequestDto {

    @NotBlank(message = "Restaurant name cannot be blank")
    @Size(min = 2, max = 100, message = "Restaurant name must be between 2 and 100 characters")
    private String name;

    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description;

    @NotBlank(message = "Address cannot be blank")
    @Size(max = 255, message = "Address cannot exceed 255 characters")
    private String address;

    @NotBlank(message = "Phone number cannot be blank")
    @Size(max = 20, message = "Phone number cannot exceed 20 characters")
    private String phoneNumber;

    @Email(message = "Restaurant email should be valid")
    @Size(max = 100, message = "Restaurant email cannot exceed 100 characters")
    private String email; // Contact email for the restaurant

    // We can add fields for initial restaurant admins (e.g., Set<Long> adminUserIds) later if needed.
    // For now, keep it simple. Admin assignment can be a separate operation or part of an update.
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/RestaurantResponseDto.java ===
package com.multirestaurantplatform.restaurant.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;
import java.util.Set; // For future use if we include admin usernames or IDs

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class RestaurantResponseDto {
    private Long id;
    private String name;
    private String description;
    private String address;
    private String phoneNumber;
    private String email;
    private boolean isActive;
    private Instant createdAt;
    private Instant updatedAt;
    // We can add a Set<String> restaurantAdminUsernames later if needed
    // For now, keeping it simple. The controller will map from the Restaurant entity.
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/UpdateRestaurantRequestDto.java ===
// File: backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/dto/UpdateRestaurantRequestDto.java
package com.multirestaurantplatform.restaurant.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set; // Import Set

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UpdateRestaurantRequestDto {

    @Size(min = 2, max = 100, message = "Restaurant name must be between 2 and 100 characters")
    private String name; // Can be null

    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    private String description; // Can be null

    @Size(max = 255, message = "Address cannot exceed 255 characters")
    private String address; // Can be null

    @Size(max = 20, message = "Phone number cannot exceed 20 characters")
    private String phoneNumber; // Can be null

    @Email(message = "Restaurant email should be valid")
    @Size(max = 100, message = "Restaurant email cannot exceed 100 characters")
    private String email; // Can be null

    private Boolean isActive; // Can be null (use Boolean wrapper type)

    // New field to manage restaurant administrators
    // This field is optional. If provided, it will replace the existing set of admins for the restaurant.
    // If null, the admins will not be changed. If an empty set, all admins will be removed.
    private Set<Long> adminUserIds; // Can be null
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/repository/RestaurantRepository.java ===
package com.multirestaurantplatform.restaurant.repository;

import com.multirestaurantplatform.restaurant.model.Restaurant;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RestaurantRepository extends JpaRepository<Restaurant, Long> {

    // Example: Find a restaurant by its exact name (case-sensitive)
    Optional<Restaurant> findByName(String name);

    // Example: Find a restaurant by its email (case-sensitive)
    Optional<Restaurant> findByEmail(String email);

    // You can add more custom query methods here as needed, e.g.:
    // List<Restaurant> findByIsActiveTrue();
    // Page<Restaurant> findByNameContainingIgnoreCase(String name, Pageable pageable);
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/model/Restaurant.java ===
package com.multirestaurantplatform.restaurant.model;

import com.multirestaurantplatform.common.model.BaseEntity;
import com.multirestaurantplatform.security.model.User; // Keep this import
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "restaurants")
public class Restaurant extends BaseEntity {

    @NotBlank(message = "Restaurant name cannot be blank")
    @Size(min = 2, max = 100, message = "Restaurant name must be between 2 and 100 characters")
    @Column(nullable = false, length = 100, unique = true)
    private String name;

    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    @Column(length = 1000)
    private String description;

    @NotBlank(message = "Address cannot be blank")
    @Size(max = 255, message = "Address cannot exceed 255 characters")
    @Column(nullable = false)
    private String address;

    @NotBlank(message = "Phone number cannot be blank")
    @Size(max = 20, message = "Phone number cannot exceed 20 characters")
    @Column(nullable = false, length = 20)
    private String phoneNumber;

    @Email(message = "Restaurant email should be valid")
    @Size(max = 100, message = "Restaurant email cannot exceed 100 characters")
    @Column(length = 100, unique = true)
    private String email;

    @Column(nullable = false)
    private boolean isActive = true;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "restaurant_admins",
            joinColumns = @JoinColumn(name = "restaurant_id"),
            inverseJoinColumns = @JoinColumn(name = "user_id"))
    private Set<User> restaurantAdmins = new HashSet<>();


}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantSecurityService.java ===
package com.multirestaurantplatform.restaurant.service;

public interface RestaurantSecurityService {

    /**
     * Checks if the currently authenticated user (identified by username) is an administrator
     * for the specified restaurant.
     *
     * @param restaurantId The ID of the restaurant to check.
     * @param username The username of the authenticated user.
     * @return true if the user is an administrator for the restaurant, false otherwise.
     */
    boolean isRestaurantAdminForRestaurant(Long restaurantId, String username);
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantSecurityServiceImpl.java ===
package com.multirestaurantplatform.restaurant.service;

import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.repository.RestaurantRepository;
import com.multirestaurantplatform.security.model.Role; // Import Role
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service("restaurantSecurityServiceImpl") // Explicit bean name to match SpEL expression
@RequiredArgsConstructor
public class RestaurantSecurityServiceImpl implements RestaurantSecurityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestaurantSecurityServiceImpl.class);

    private final RestaurantRepository restaurantRepository;
    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true) // Ensures the session is active for lazy loading if needed
    public boolean isRestaurantAdminForRestaurant(Long restaurantId, String username) {
        LOGGER.debug("SecurityCheck: Checking if user '{}' is admin for restaurant ID '{}'", username, restaurantId);

        Optional<User> userOptional = userRepository.findByUsername(username);
        if (userOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: User '{}' not found.", username);
            return false; // User not found, so cannot be an admin
        }
        User user = userOptional.get();

        // Ensure the user actually has the RESTAURANT_ADMIN role.
        // While the @PreAuthorize might check hasRole('RESTAURANT_ADMIN') first,
        // it's good practice for this specific service method to also be mindful of the role
        // or assume the caller (SpEL) has already filtered by role.
        // For robustness, we can add a check here, though SpEL usually handles the role part.
        boolean isRestaurantAdminRole = user.getRoles().stream()
                .anyMatch(role -> role == Role.RESTAURANT_ADMIN);
        if (!isRestaurantAdminRole) {
            LOGGER.debug("SecurityCheck: User '{}' does not have RESTAURANT_ADMIN role.", username);
            // If the SpEL is "(hasRole('RESTAURANT_ADMIN') AND @bean.method())",
            // this check might be redundant but harmless.
            // If SpEL was just "@bean.method()", this check would be critical.
            return false;
        }


        Optional<Restaurant> restaurantOptional = restaurantRepository.findById(restaurantId);
        if (restaurantOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: Restaurant ID '{}' not found.", restaurantId);
            return false; // Restaurant not found
        }
        Restaurant restaurant = restaurantOptional.get();

        // Hibernate will lazy-load restaurant.getRestaurantAdmins() if the session is active.
        // The @Transactional annotation ensures this.
        // We check if the user's ID is present in the set of admin IDs for the restaurant.
        boolean isUserAdminForThisRestaurant = restaurant.getRestaurantAdmins().stream()
                .anyMatch(adminUser -> adminUser.getId().equals(user.getId()));

        if (isUserAdminForThisRestaurant) {
            LOGGER.info("SecurityCheck: User '{}' IS an admin for restaurant ID '{}'. Access granted by this check.", username, restaurantId);
        } else {
            LOGGER.info("SecurityCheck: User '{}' is NOT an admin for restaurant ID '{}'. Access denied by this check.", username, restaurantId);
        }

        return isUserAdminForThisRestaurant;
    }
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantService.java ===
package com.multirestaurantplatform.restaurant.service;

import com.multirestaurantplatform.restaurant.dto.CreateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.dto.UpdateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.model.Restaurant; // Ensure this is the correct model import

import java.util.List;

public interface RestaurantService {

    /**
     * Creates a new restaurant.
     * @param createDto DTO containing data for the new restaurant.
     * @return The created Restaurant entity.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if name or email already exists.
     */
    Restaurant createRestaurant(CreateRestaurantRequestDto createDto);

    /**
     * Finds a restaurant by its ID.
     * @param id The ID of the restaurant.
     * @return The found Restaurant entity.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if restaurant not found.
     */
    Restaurant findRestaurantById(Long id);

    /**
     * Retrieves all restaurants.
     * (Consider adding pagination and filtering in a future iteration)
     * @return A list of all Restaurant entities.
     */
    List<Restaurant> findAllRestaurants();

    /**
     * Updates an existing restaurant.
     * @param id The ID of the restaurant to update.
     * @param updateDto DTO containing data to update.
     * @return The updated Restaurant entity.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if restaurant not found.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if updated name or email conflicts with another restaurant.
     */
    Restaurant updateRestaurant(Long id, UpdateRestaurantRequestDto updateDto);

    /**
     * Deletes a restaurant by its ID.
     * (Consider soft delete by setting isActive=false vs hard delete)
     * @param id The ID of the restaurant to delete.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if restaurant not found.
     */
    void deleteRestaurant(Long id); // For now, a hard delete. Soft delete can be implemented by updating 'isActive'.

    // Future methods could include:
    // Restaurant addAdminToRestaurant(Long restaurantId, Long userId);
    // Restaurant removeAdminFromRestaurant(Long restaurantId, Long userId);
}
=== backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantServiceImpl.java ===
// File: backend/restaurant/src/main/java/com/multirestaurantplatform/restaurant/service/RestaurantServiceImpl.java
package com.multirestaurantplatform.restaurant.service;

import com.multirestaurantplatform.common.exception.BadRequestException;
import com.multirestaurantplatform.common.exception.ConflictException;
import com.multirestaurantplatform.common.exception.ResourceNotFoundException;
import com.multirestaurantplatform.restaurant.dto.CreateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.dto.UpdateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.repository.RestaurantRepository;
import com.multirestaurantplatform.security.model.Role; // Import Role
import com.multirestaurantplatform.security.model.User;   // Import User
import com.multirestaurantplatform.security.repository.UserRepository; // Import UserRepository

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor // Lombok for constructor injection
public class RestaurantServiceImpl implements RestaurantService {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestaurantServiceImpl.class);

    private final RestaurantRepository restaurantRepository;
    private final UserRepository userRepository; // Added UserRepository

    @Override
    @Transactional
    public Restaurant createRestaurant(CreateRestaurantRequestDto createDto) {
        LOGGER.info("Attempting to create restaurant with name: {}", createDto.getName());

        restaurantRepository.findByName(createDto.getName()).ifPresent(r -> {
            LOGGER.warn("Restaurant creation failed: name '{}' already exists.", createDto.getName());
            throw new ConflictException("Restaurant with name '" + createDto.getName() + "' already exists.");
        });

        if (StringUtils.hasText(createDto.getEmail())) {
            restaurantRepository.findByEmail(createDto.getEmail()).ifPresent(r -> {
                LOGGER.warn("Restaurant creation failed: email '{}' already exists.", createDto.getEmail());
                throw new ConflictException("Restaurant with email '" + createDto.getEmail() + "' already exists.");
            });
        }

        Restaurant restaurant = new Restaurant();
        restaurant.setName(createDto.getName());
        restaurant.setDescription(createDto.getDescription());
        restaurant.setAddress(createDto.getAddress());
        restaurant.setPhoneNumber(createDto.getPhoneNumber());
        restaurant.setEmail(createDto.getEmail());
        restaurant.setActive(true);
        // Initially, no admins are assigned via create. Admins are set via update.
        restaurant.setRestaurantAdmins(new HashSet<>());

        Restaurant savedRestaurant = restaurantRepository.save(restaurant);
        LOGGER.info("Restaurant created successfully with ID: {}", savedRestaurant.getId());
        return savedRestaurant;
    }

    @Override
    @Transactional(readOnly = true)
    public Restaurant findRestaurantById(Long id) {
        LOGGER.debug("Attempting to find restaurant with ID: {}", id);
        return restaurantRepository.findById(id)
                .orElseThrow(() -> {
                    LOGGER.warn("Restaurant not found with ID: {}", id);
                    return new ResourceNotFoundException("Restaurant not found with ID: " + id);
                });
    }

    @Override
    @Transactional(readOnly = true)
    public List<Restaurant> findAllRestaurants() {
        LOGGER.debug("Fetching all restaurants");
        return restaurantRepository.findAll();
    }

    @Override
    @Transactional
    public Restaurant updateRestaurant(Long id, UpdateRestaurantRequestDto updateDto) {
        LOGGER.info("Attempting to update restaurant with ID: {}", id);
        Restaurant restaurant = findRestaurantById(id); // Throws ResourceNotFoundException if not found

        // Update basic fields
        if (updateDto.getName() != null) {
            String newName = updateDto.getName();
            if (!newName.equals(restaurant.getName())) {
                restaurantRepository.findByName(newName).ifPresent(existing -> {
                    if (!existing.getId().equals(id)) {
                        LOGGER.warn("Restaurant update failed for ID {}: name '{}' already exists for restaurant ID {}.", id, newName, existing.getId());
                        throw new ConflictException("Restaurant with name '" + newName + "' already exists.");
                    }
                });
                restaurant.setName(newName);
            }
        }

        if (updateDto.getEmail() != null) {
            String newEmail = updateDto.getEmail();
            if (StringUtils.hasText(newEmail) && !newEmail.equals(restaurant.getEmail())) {
                restaurantRepository.findByEmail(newEmail).ifPresent(existing -> {
                    if (!existing.getId().equals(id)) {
                        LOGGER.warn("Restaurant update failed for ID {}: email '{}' already exists for restaurant ID {}.", id, newEmail, existing.getId());
                        throw new ConflictException("Restaurant with email '" + newEmail + "' already exists.");
                    }
                });
                restaurant.setEmail(newEmail);
            } else if (updateDto.getEmail().isEmpty() && restaurant.getEmail() != null) {
                restaurant.setEmail(null);
            }
        }

        if (updateDto.getDescription() != null) {
            restaurant.setDescription(updateDto.getDescription());
        }
        if (updateDto.getAddress() != null) {
            restaurant.setAddress(updateDto.getAddress());
        }
        if (updateDto.getPhoneNumber() != null) {
            restaurant.setPhoneNumber(updateDto.getPhoneNumber());
        }
        if (updateDto.getIsActive() != null) {
            restaurant.setActive(updateDto.getIsActive());
        }

        // --- Handle Restaurant Admin Assignment ---
        if (updateDto.getAdminUserIds() != null) {
            LOGGER.info("Updating administrators for restaurant ID: {}. Provided adminUserIds: {}", id, updateDto.getAdminUserIds());
            Set<User> newAdmins = new HashSet<>();
            if (!updateDto.getAdminUserIds().isEmpty()) {
                for (Long adminUserId : updateDto.getAdminUserIds()) {
                    User potentialAdmin = userRepository.findById(adminUserId)
                            .orElseThrow(() -> {
                                LOGGER.warn("User with ID {} not found while assigning admins to restaurant ID {}", adminUserId, id);
                                return new ResourceNotFoundException("User not found with ID: " + adminUserId + " for admin assignment.");
                            });

                    if (!potentialAdmin.getRoles().contains(Role.RESTAURANT_ADMIN)) {
                        LOGGER.warn("User with ID {} (username: {}) does not have RESTAURANT_ADMIN role. Cannot assign as admin to restaurant ID {}",
                                adminUserId, potentialAdmin.getUsername(), id);
                        throw new BadRequestException("User " + potentialAdmin.getUsername() + " (ID: " + adminUserId + ") is not a RESTAURANT_ADMIN and cannot be assigned to manage a restaurant.");
                    }
                    newAdmins.add(potentialAdmin);
                    LOGGER.debug("User {} (ID: {}) added as potential admin for restaurant ID {}", potentialAdmin.getUsername(), adminUserId, id);
                }
            }
            // Replace the existing set of admins with the new set
            restaurant.getRestaurantAdmins().clear(); // Clear existing admins first
            restaurant.getRestaurantAdmins().addAll(newAdmins); // Add new admins
            LOGGER.info("Successfully processed adminUserIds for restaurant ID: {}. New admin count: {}", id, newAdmins.size());
        }
        // If updateDto.getAdminUserIds() is null, the existing admins are not modified.

        Restaurant updatedRestaurant = restaurantRepository.save(restaurant);
        LOGGER.info("Restaurant with ID: {} updated successfully.", id);
        return updatedRestaurant;
    }

    @Override
    @Transactional
    public void deleteRestaurant(Long id) {
        LOGGER.info("Attempting to delete restaurant with ID: {}", id);
        if (!restaurantRepository.existsById(id)) {
            LOGGER.warn("Restaurant deletion failed: not found with ID: {}", id);
            throw new ResourceNotFoundException("Restaurant not found with ID: " + id + " for deletion.");
        }
        // Before deleting a restaurant, consider implications for related entities (e.g., menus, orders).
        // Depending on cascading rules or business logic, you might need to handle these explicitly.
        // For example, disassociating or deleting menus. For now, we assume cascading delete or manual cleanup.
        restaurantRepository.deleteById(id);
        LOGGER.info("Restaurant with ID: {} deleted successfully.", id);
    }
}
=== backend/security/build.gradle ===
// File: multi-restaurant-platform/backend/security/build.gradle
plugins {
    id 'java-library'
}

// Updated description
description = 'The security module handling authentication, authorization, users, roles, JWT, etc.'

// Define jjwt version for consistency
ext {
    jjwtVersion = '0.12.5' // Use a recent stable version of JJWT
}

dependencies {
    // Dependency on the common module (for BaseEntity, etc.)
    implementation project(':backend:common')

    // Spring Boot Security Starter (version managed by BOM in root)
    implementation 'org.springframework.boot:spring-boot-starter-security'

    // Jakarta Bean Validation API
    api 'jakarta.validation:jakarta.validation-api'

    // Spring Boot Validation Starter
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // --- Jakarta Servlet API ---
    // This is needed because classes like JwtAuthenticationFilter and JwtAuthenticationEntryPoint
    // use HttpServletRequest, HttpServletResponse, ServletException, etc.
    // These are not automatically brought in by spring-boot-starter-security for a java-library module.
    // The version will be managed by Spring Boot's dependency management.
    compileOnly 'jakarta.servlet:jakarta.servlet-api'

    // Lombok is inherited from the root build.gradle's subprojects block

    // --- JWT Dependencies ---
    implementation "io.jsonwebtoken:jjwt-api:${jjwtVersion}"
    runtimeOnly "io.jsonwebtoken:jjwt-impl:${jjwtVersion}"
    runtimeOnly "io.jsonwebtoken:jjwt-jackson:${jjwtVersion}"

    // --- Test Dependencies ---
    // Add JUnit 5 and Spring Test dependencies for testing JWT services
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/JwtAuthenticationResponse.java ===
package com.multirestaurantplatform.security.dto;

import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor; // Added for Jackson deserialization

/**
 * Represents the response payload containing the JWT access token.
 */
@Getter
@Setter
@NoArgsConstructor // Provides a no-argument constructor, essential for Jackson deserialization
public class JwtAuthenticationResponse {

    private String accessToken;
    private String tokenType = "Bearer"; // Default token type

    /**
     * Constructs a new JwtAuthenticationResponse with the given access token.
     * The tokenType will default to "Bearer".
     *
     * @param accessToken The JWT access token.
     */
    public JwtAuthenticationResponse(String accessToken) {
        this.accessToken = accessToken;
        // tokenType will retain its default "Bearer" or be set by Jackson's setter if present in JSON
    }

    // Optional: If you need a constructor that sets all fields,
    // you could add @AllArgsConstructor from Lombok, or define it manually:
    //
    // import lombok.AllArgsConstructor;
    // @AllArgsConstructor
    //
    // public JwtAuthenticationResponse(String accessToken, String tokenType) {
    //     this.accessToken = accessToken;
    //     this.tokenType = tokenType;
    // }

    // --- Commented out optional fields for user details ---
    // private String username;
    // private java.util.Collection<? extends org.springframework.security.core.GrantedAuthority> authorities;
    //
    // public JwtAuthenticationResponse(String accessToken, String username, java.util.Collection<? extends org.springframework.security.core.GrantedAuthority> authorities) {
    //     this.accessToken = accessToken;
    //     this.username = username;
    //     this.authorities = authorities;
    // }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/LoginRequest.java ===
package com.multirestaurantplatform.security.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data // Lombok: Generates getters, setters, toString, equals, hashCode, and a constructor for all final fields.
public class LoginRequest {

    @NotBlank(message = "Username cannot be blank")
    private String username;

    @NotBlank(message = "Password cannot be blank")
    private String password;

    // No-args constructor (Lombok @Data might provide one, but explicit can be good)
    public LoginRequest() {
    }

    // All-args constructor (Lombok @Data will provide one for final fields, but this is explicit)
    public LoginRequest(String username, String password) {
        this.username = username;
        this.password = password;
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/RegisterRequest.java ===
package com.multirestaurantplatform.security.dto;

import com.multirestaurantplatform.security.model.Role; // Assuming Role enum is in model package
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;
import lombok.Data; // Lombok annotation for boilerplate code (getters, setters, equals, hashCode, toString)

import java.util.Set;

@Data // Bundles @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor
public class RegisterRequest {

    @NotBlank(message = "Username cannot be blank")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @NotBlank(message = "Password cannot be blank")
    @Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters") // Validate length before hashing
    private String password;

    @NotBlank(message = "Email cannot be blank")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email cannot exceed 100 characters")
    private String email;

    @NotEmpty(message = "User must have at least one role")
    private Set<Role> roles; // Specify the roles during registration (e.g., CUSTOMER)
                            // In a real app, you might default this or derive it differently.
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/dto/UserResponseDto.java ===
package com.multirestaurantplatform.security.dto;

import com.multirestaurantplatform.security.model.Role; // Assuming Role is in this package
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserResponseDto {
    private Long id;
    private String username;
    private String email;
    private Set<Role> roles;

    // We can add a static factory method or use a mapping library like MapStruct later
    // for cleaner conversion from User entity to UserResponseDto if needed.
    // For now, manual mapping in the controller/service is fine for simplicity.
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/repository/UserRepository.java ===
package com.multirestaurantplatform.security.repository;

import com.multirestaurantplatform.security.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

/**
 * Spring Data JPA repository for the User entity.
 */
@Repository // Indicates this is a Spring bean and provides exception translation
public interface UserRepository extends JpaRepository<User, Long> { // <EntityType, IdType>

    // --- Spring Data JPA Query Methods ---
    // Implementations are automatically generated based on method names.

    /**
     * Finds a user by their username. Spring Data JPA generates the query.
     * Consider if username search should be case-insensitive based on requirements.
     * @param username The username to search for.
     * @return An Optional containing the found User or empty if not found.
     */
    Optional<User> findByUsername(String username);

    /**
     * Finds a user by their email address. Spring Data JPA generates the query.
     * Consider if email search should be case-insensitive.
     * @param email The email address to search for.
     * @return An Optional containing the found User or empty if not found.
     */
    Optional<User> findByEmail(String email);

    /**
     * Checks if a user exists with the given username.
     * More efficient than findByUsername().isPresent().
     * @param username The username to check.
     * @return true if a user with the username exists, false otherwise.
     */
    boolean existsByUsername(String username);

    /**
     * Checks if a user exists with the given email address.
     * More efficient than findByEmail().isPresent().
     * @param email The email address to check.
     * @return true if a user with the email exists, false otherwise.
     */
    boolean existsByEmail(String email);

    // We can add more complex queries using @Query annotation later if needed.
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/config/JwtAuthenticationEntryPoint.java ===
package com.multirestaurantplatform.security.config; // Or your chosen package for this class

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component // Marks this as a Spring component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationEntryPoint.class);

    /**
     * This method is invoked when an unauthenticated user attempts to access a secured REST resource.
     * It sends an HTTP 401 Unauthorized response.
     *
     * @param request       that resulted in an <code>AuthenticationException</code>
     * @param response      so that the user agent can begin authentication
     * @param authException that caused the invocation
     */
    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException, ServletException {
        // Log the unauthorized attempt for monitoring/debugging purposes
        LOGGER.error("Unauthorized error: {}. Path: {}", authException.getMessage(), request.getRequestURI());

        // Send an HTTP 401 Unauthorized error back to the client
        // You can customize the response further if needed, e.g., by sending a JSON body
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Error: Unauthorized - " + authException.getMessage());
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/config/SecurityConfig.java ===
package com.multirestaurantplatform.security.config;

import com.multirestaurantplatform.security.filter.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer; // Import for frameOptions
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
// import org.springframework.boot.autoconfigure.security.servlet.PathRequest; // Not strictly needed if using specific path matchers

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint unauthorizedHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(unauthorizedHandler)
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(
                                "/api/v1/auth/**",         // Login, Register
                                "/api/v1/test/health",     // Health check path
                                "/swagger-ui.html",
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/webjars/**",
                                "/h2-console/**"          // Permit H2 console access
                        ).permitAll()
                        .anyRequest().authenticated() // All other requests need authentication
                )
                // Configure headers, specifically for X-Frame-Options to allow H2 console
                // This is a common way to allow H2 console frames.
                // Spring Security 6.x new way to configure headers.
                .headers(headers ->
                        headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin // Allow framing from same origin for H2 console
                                // Or, if sameOrigin doesn't work for some reason with H2 console's specific setup:
                                // headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::disable) // Less secure, but might be needed for H2 console
                        )
                );


        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/model/Role.java ===
package com.multirestaurantplatform.security.model;

/**
 * Defines the user roles within the application.
 * Corresponds to authorities in Spring Security.
 */
public enum Role {
    CUSTOMER,        // Regular customer placing orders
    RESTAURANT_ADMIN,// Manages a specific restaurant (menus, orders, settings)
    ADMIN            // Platform administrator (manages restaurants, users, platform settings)
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/model/User.java ===
package com.multirestaurantplatform.security.model;

import com.multirestaurantplatform.common.model.BaseEntity;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor; // Example constructor if needed
import lombok.AllArgsConstructor; // Example constructor if needed

import java.util.Set;

@Getter
@Setter
@NoArgsConstructor // Generates a no-args constructor (required by JPA)
@AllArgsConstructor // Optional: Generates an all-args constructor
@Entity
@Table(name = "users", // Explicitly naming the table "users"
       uniqueConstraints = { // Adding unique constraints at the table level
           @UniqueConstraint(columnNames = "username"),
           @UniqueConstraint(columnNames = "email")
       })
public class User extends BaseEntity {

    @NotBlank // From jakarta.validation.constraints - ensures not null and not just whitespace
    @Size(min = 3, max = 50)
    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @NotBlank
    @Size(min = 8, max = 100) // Store hashed passwords, so length should be sufficient
    @Column(nullable = false, length = 100)
    private String password; // Store hashed passwords ONLY

    @NotBlank
    @Email // Validates if the string is a well-formed email address
    @Size(max = 100)
    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @NotNull // A user must have at least one role
    @Enumerated(EnumType.STRING) // Store the enum name (e.g., "ADMIN") as a string in the DB
    @ElementCollection(fetch = FetchType.EAGER) // Store roles in a separate table (user_roles)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id")) // Customize the join table
    @Column(name = "role", nullable = false) // Column name in the join table
    private Set<Role> roles;

    // Optional: Add other fields like firstName, lastName, phoneNumber, isActive, etc. later
    // private String firstName;
    // private String lastName;
    // private String phoneNumber;
    // private boolean isActive = true; // Default to active

    // Inherits id, createdAt, updatedAt from BaseEntity
    // Inherits equals() and hashCode() from BaseEntity (based on ID)
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/filter/JwtAuthenticationFilter.java ===
package com.multirestaurantplatform.security.filter;

import com.multirestaurantplatform.security.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value; // Ensure this import is present
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationFilter.class);

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Value("${app.jwt.token-prefix}")
    private String tokenPrefix; // Example: "Bearer"

    private static final String AUTHORIZATION_HEADER = "Authorization";

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        LOGGER.debug("JwtAuthenticationFilter: Processing request for URI: {}", request.getRequestURI());
        LOGGER.debug("JwtAuthenticationFilter: Injected tokenPrefix: [{}]", tokenPrefix); // Log the injected prefix

        try {
            final String authHeader = request.getHeader(AUTHORIZATION_HEADER);
            LOGGER.debug("JwtAuthenticationFilter: Authorization Header: [{}]", authHeader);

            if (!StringUtils.hasText(tokenPrefix)) {
                LOGGER.error("JwtAuthenticationFilter: tokenPrefix is not configured or empty! Check 'app.jwt.token-prefix' in properties.");
                filterChain.doFilter(request, response);
                return;
            }

            final String expectedPrefixWithSpace = tokenPrefix + " ";

            if (!StringUtils.hasText(authHeader) || !authHeader.startsWith(expectedPrefixWithSpace)) {
                LOGGER.debug("JwtAuthenticationFilter: JWT Token does not begin with Bearer string or is missing. Header: [{}], Expected Prefix: [{}]", authHeader, expectedPrefixWithSpace);
                filterChain.doFilter(request, response);
                return;
            }

            final String jwt = authHeader.substring(expectedPrefixWithSpace.length());
            LOGGER.debug("JwtAuthenticationFilter: Extracted JWT: [{}]", jwt);

            final String username = jwtService.extractUsername(jwt);
            LOGGER.debug("JwtAuthenticationFilter: Username extracted from JWT: [{}]", username);

            if (StringUtils.hasText(username) && SecurityContextHolder.getContext().getAuthentication() == null) {
                LOGGER.debug("JwtAuthenticationFilter: Username [{}] extracted, SecurityContext is null. Attempting to load UserDetails.", username);
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

                if (userDetails != null) {
                    LOGGER.debug("JwtAuthenticationFilter: UserDetails loaded for username: [{}], Authorities: {}", userDetails.getUsername(), userDetails.getAuthorities());
                    boolean isTokenValid = jwtService.isTokenValid(jwt, userDetails);
                    LOGGER.debug("JwtAuthenticationFilter: Is token valid for username [{}]: {}", username, isTokenValid);

                    if (isTokenValid) {
                        UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                        authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(authToken);
                        LOGGER.info("JwtAuthenticationFilter: Successfully authenticated user [{}] and set SecurityContext.", username);
                    } else {
                        LOGGER.warn("JwtAuthenticationFilter: JWT token validation failed for user: {}", username);
                    }
                } else {
                    LOGGER.warn("JwtAuthenticationFilter: UserDetails not found for username extracted from token: {}", username);
                }
            } else {
                LOGGER.debug("JwtAuthenticationFilter: Username not extracted from JWT or SecurityContext already contains authentication. Username: [{}], Auth: {}", username, SecurityContextHolder.getContext().getAuthentication());
            }
        } catch (Exception e) {
            LOGGER.error("JwtAuthenticationFilter: Cannot set user authentication. Error: {}", e.getMessage(), e);
            // SecurityContextHolder.clearContext(); // Consider if necessary
        }

        filterChain.doFilter(request, response);
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/JwtService.java ===
package com.multirestaurantplatform.security.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {

    private static final Logger LOGGER = LoggerFactory.getLogger(JwtService.class);

    @Value("${app.jwt.secret}")
    private String jwtSecretString;

    @Value("${app.jwt.expiration-ms}")
    private long jwtExpirationMs;

    /**
     * HMAC key derived from {@code jwtSecretString}. The type must be {@link SecretKey}
     * so that the new JJWT 0.12 verify/sign methods resolve without a cast.
     */
    private SecretKey signingKey;

    /**
     * Convert the Base64‚Äëencoded secret string into a {@link SecretKey} once the bean is ready.
     */
    @PostConstruct
    public void init() {
        if (jwtSecretString == null || jwtSecretString.trim().isEmpty()) {
            LOGGER.error("JWT secret key is null or empty ‚Äì check app.jwt.secret");
            throw new IllegalArgumentException("JWT secret key cannot be null or empty");
        }
        try {
            byte[] keyBytes = Decoders.BASE64.decode(jwtSecretString);
            this.signingKey = Keys.hmacShaKeyFor(keyBytes);
        } catch (Exception ex) {
            LOGGER.error("Invalid Base64 value for app.jwt.secret: {}", ex.getMessage());
            throw new IllegalArgumentException("Invalid JWT secret key", ex);
        }
    }

    /* ---------------------------------------------------------------------
     *  Public API
     * ------------------------------------------------------------------ */

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public <T> T extractClaim(String token, Function<Claims, T> resolver) {
        return resolver.apply(extractAllClaims(token));
    }

    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    /**
     * Build a JWS with optional extra claims using the JJWT 0.12 fluent API
     * (no deprecated setters).
     */
    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {
        long now = System.currentTimeMillis();
        return Jwts.builder()
                .claims()                   // switch into the Claims builder
                .add(extraClaims)       // merge custom claims
                .subject(userDetails.getUsername())
                .issuedAt(new Date(now))
                .expiration(new Date(now + jwtExpirationMs))
                .and()                  // back to the main builder
                .signWith(signingKey, Jwts.SIG.HS256)
                .compact();
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        try {
            return userDetails.getUsername().equals(extractUsername(token)) && !isTokenExpired(token);
        } catch (io.jsonwebtoken.JwtException ex) {
            LOGGER.warn("JWT validation failed for user {}: {}", userDetails.getUsername(), ex.getMessage());
            return false;
        }
    }

    /* ---------------------------------------------------------------------
     *  Private helpers
     * ------------------------------------------------------------------ */

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    /**
     * Parse and verify the supplied compact JWS, returning its {@link Claims} payload.
     */
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(signingKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/UserDetailsServiceImpl.java ===
package com.multirestaurantplatform.security.service;

import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private static final Logger LOGGER = LoggerFactory.getLogger(UserDetailsServiceImpl.class);

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        LOGGER.debug("Attempting to load user by username: {}", username);

        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> {
                    LOGGER.warn("User not found with username: {}", username);
                    return new UsernameNotFoundException("User not found with username: " + username);
                });

        LOGGER.info("User found: {}. Stored hashed password: [PROTECTED]", user.getUsername()); // Don't log the actual hash unless for very specific, temporary debugging.
        // For temporary deep debugging, you could log user.getPassword() but remove it immediately after.
        // LOGGER.debug("Hashed password from DB for user {}: {}", username, user.getPassword());


        Collection<? extends GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> {
                    LOGGER.debug("Mapping role: {} to authority: ROLE_{}", role.name(), role.name());
                    return new SimpleGrantedAuthority("ROLE_" + role.name());
                })
                .collect(Collectors.toSet());

        LOGGER.debug("Authorities for user {}: {}", username, authorities);

        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(), // This is the stored hashed password
                true, // enabled
                true, // accountNonExpired
                true, // credentialsNonExpired
                true, // accountNonLocked
                authorities);
    }
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/UserService.java ===
package com.multirestaurantplatform.security.service;

import com.multirestaurantplatform.common.exception.ResourceNotFoundException; // Import
import com.multirestaurantplatform.security.dto.RegisterRequest;
import com.multirestaurantplatform.security.model.User;

public interface UserService {
    /**
     * Registers a new user based on the provided request data.
     * Handles password encoding and checks for existing username/email.
     *
     * @param registerRequest The user registration data.
     * @return The newly created User entity.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if username or email already exists.
     */
    User registerUser(RegisterRequest registerRequest);

    /**
     * Finds a user by their username.
     *
     * @param username The username to search for.
     * @return The found User entity.
     * @throws ResourceNotFoundException if no user is found with the given username.
     */
    User findUserByUsername(String username);

    /**
     * Finds a user by their ID.
     *
     * @param id The ID of the user to search for.
     * @return The found User entity.
     * @throws ResourceNotFoundException if no user is found with the given ID.
     */
    User findUserById(Long id);

    /**
     * Finds a user by their email address.
     *
     * @param email The email address to search for.
     * @return The found User entity.
     * @throws ResourceNotFoundException if no user is found with the given email.
     */
    User findUserByEmail(String email);

    // Add other methods later, e.g.:
    // User updateUserProfile(Long userId, UpdateProfileRequest request);
}
=== backend/security/src/main/java/com/multirestaurantplatform/security/service/UserServiceImpl.java ===
package com.multirestaurantplatform.security.service;

import com.multirestaurantplatform.common.exception.ConflictException;
import com.multirestaurantplatform.common.exception.ResourceNotFoundException; // Import
import com.multirestaurantplatform.security.dto.RegisterRequest;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor // Lombok: Creates constructor injecting final fields
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder; // Inject the PasswordEncoder bean

    @Override
    @Transactional // Use transaction for operations involving database writes/reads
    public User registerUser(RegisterRequest request) {
        // 1. Check if username already exists
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new ConflictException("Error: Username '" + request.getUsername() + "' is already taken!");
        }

        // 2. Check if email already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ConflictException("Error: Email '" + request.getEmail() + "' is already in use!");
        }

        // 3. Create new user's account
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setRoles(request.getRoles());

        return userRepository.save(user);
    }

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public User findUserByUsername(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with username: " + username));
    }

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public User findUserById(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + id));
    }

    @Override
    @Transactional(readOnly = true) // Good practice for read operations
    public User findUserByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with email: " + email));
    }
}
=== backend/payment/build.gradle ===
// File: multi-restaurant-platform/backend/payment/build.gradle
// Replace payment with payment, security, etc.
plugins {
    id 'java-library' // Use 'java-library' for modules that are intended to be used as libraries by other modules
}

description = 'The payment module' // e.g., 'The payment module'

dependencies {
    // Module-specific dependencies will be added here later
    // Example:
    // implementation 'org.springframework.boot:spring-boot-starter' // If it needs basic Spring Boot utilities but is not a web app
}
=== backend/admin/build.gradle ===
// File: multi-restaurant-platform/backend/admin/build.gradle
// Replace admin with admin, security, etc.
plugins {
    id 'java-library' // Use 'java-library' for modules that are intended to be used as libraries by other modules
}

description = 'The admin module' // e.g., 'The admin module'

dependencies {
    // Module-specific dependencies will be added here later
    // Example:
    // implementation 'org.springframework.boot:spring-boot-starter' // If it needs basic Spring Boot utilities but is not a web app
}
=== backend/print/build.gradle ===
// File: multi-restaurant-platform/backend/print/build.gradle
// Replace print with print, security, etc.
plugins {
    id 'java-library' // Use 'java-library' for modules that are intended to be used as libraries by other modules
}

description = 'The print module' // e.g., 'The print module'

dependencies {
    // Module-specific dependencies will be added here later
    // Example:
    // implementation 'org.springframework.boot:spring-boot-starter' // If it needs basic Spring Boot utilities but is not a web app
}
=== backend/common/build.gradle ===
plugins {
    id 'java-library'
}

description = 'The common module containing shared classes like base entities, DTOs, exceptions, etc.'

dependencies {
    // JPA API for annotations like @Entity, @Id, @MappedSuperclass etc.
    // Version managed by Spring Boot BOM imported in root project
    api 'jakarta.persistence:jakarta.persistence-api'

    // Spring Data JPA starter - Version managed by Spring Boot BOM
    api 'org.springframework.boot:spring-boot-starter-data-jpa'

    // Lombok dependencies are now managed in the root build.gradle's subprojects block
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/model/BaseEntity.java ===
package com.multirestaurantplatform.common.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import java.io.Serializable;
import java.time.Instant;
import java.util.Objects;

@Getter
@Setter
@MappedSuperclass // Specifies that this is a base class for entities and its fields should be mapped to the columns of the inheriting entity's table.
public abstract class BaseEntity implements Serializable {

    private static final long serialVersionUID = 1L; // Recommended for Serializable classes

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-incrementing ID strategy suitable for PostgreSQL/H2
    private Long id;

    @CreationTimestamp // Automatically set the timestamp when the entity is first persisted
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @UpdateTimestamp // Automatically update the timestamp when the entity is updated
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    // --- Optional: hashCode() and equals() based on ID ---
    // Useful for JPA entity comparisons, especially within collections.

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BaseEntity that = (BaseEntity) o;
        // Use ID for equality check if it's not null, otherwise rely on object identity
        return id != null && Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        // Use getClass().hashCode() to ensure consistency across different entity types
        return id != null ? Objects.hash(getClass().hashCode(), id) : super.hashCode();
        // Or simply: return getClass().hashCode(); // If ID is sufficient for hash-based collections before persistence
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/AppException.java ===
package com.multirestaurantplatform.common.exception;

public abstract class AppException extends RuntimeException {

    public AppException(String message) {
        super(message);
    }

    public AppException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/BadRequestException.java ===
package com.multirestaurantplatform.common.exception;

public class BadRequestException extends AppException {

    public BadRequestException(String message) {
        super(message);
    }

    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/ConflictException.java ===
package com.multirestaurantplatform.common.exception;

public class ConflictException extends AppException {

    public ConflictException(String message) {
        super(message);
    }

    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/common/src/main/java/com/multirestaurantplatform/common/exception/ResourceNotFoundException.java ===
package com.multirestaurantplatform.common.exception;

public class ResourceNotFoundException extends AppException {

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== backend/menu/build.gradle ===
plugins {
    id 'java-library'
}

description = 'The menu module for managing restaurant menus, sections, and items.'

dependencies {
    // Dependency on the common module (for BaseEntity, etc.)
    implementation project(':backend:common')

    // Dependency on the restaurant module (Menu entity has a ManyToOne with Restaurant, MenuSecurityServiceImpl uses RestaurantSecurityService)
    implementation project(':backend:restaurant')

    // ***** ADD THIS LINE *****
    // Dependency on the security module (for User, Role, UserRepository used in MenuSecurityServiceImpl)
    implementation project(':backend:security')
    // *************************

    // Spring Data JPA (version managed by Spring Boot BOM in root project)
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    // Add this for Jakarta Validation API (e.g., @NotBlank, @Size)
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // Lombok is managed in the root build.gradle's subprojects block
    // compileOnly 'org.projectlombok:lombok'
    // annotationProcessor 'org.projectlombok:lombok'

    // --- Test Dependencies ---
    // Spring Boot Test Starter: Includes JUnit 5, Mockito, AssertJ, Spring Test, etc.
    // Version is managed by the Spring Boot BOM imported in the root project.
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    // Lombok for tests (also managed by root build.gradle's subprojects block, but good to be aware)
    // testCompileOnly 'org.projectlombok:lombok'
    // testAnnotationProcessor 'org.projectlombok:lombok'
}

// Ensure JUnit 5 platform is used for tests (usually configured in root build.gradle's subprojects block)
/*
tasks.withType(Test) {
    useJUnitPlatform()
}
*/
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/CreateMenuRequestDto.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/CreateMenuRequestDto.java
package com.multirestaurantplatform.menu.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CreateMenuRequestDto {

    @NotBlank(message = "Menu name cannot be blank")
    @Size(min = 2, max = 100, message = "Menu name must be between 2 and 100 characters")
    private String name;

    @Size(max = 500, message = "Description cannot exceed 500 characters") // Optional field
    private String description;

    @NotNull(message = "Restaurant ID cannot be null")
    private Long restaurantId;
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/MenuResponseDto.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/MenuResponseDto.java
        package com.multirestaurantplatform.menu.dto;

import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.Instant;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class MenuResponseDto {

    private Long id;
    private String name;
    private String description;
    private boolean isActive;
    private Long restaurantId; // To show which restaurant this menu belongs to
    private Instant createdAt;
    private Instant updatedAt;
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/UpdateMenuRequestDto.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/dto/UpdateMenuRequestDto.java
package com.multirestaurantplatform.menu.dto;

import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UpdateMenuRequestDto {

    @Size(min = 2, max = 100, message = "Menu name must be between 2 and 100 characters")
    private String name; // Optional: if null, not updated

    @Size(max = 500, message = "Description cannot exceed 500 characters")
    private String description; // Optional: if null, not updated

    private Boolean isActive; // Optional: if null, not updated
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/repository/MenuRepository.java ===
package com.multirestaurantplatform.menu.repository;

import com.multirestaurantplatform.menu.model.Menu;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface MenuRepository extends JpaRepository<Menu, Long> {

    // Find all menus for a specific restaurant
    List<Menu> findByRestaurantId(Long restaurantId);

    // Find all active menus for a specific restaurant
    List<Menu> findByRestaurantIdAndIsActiveTrue(Long restaurantId);

    // Find a menu by its name and restaurant ID (to check for duplicates within a restaurant)
    Optional<Menu> findByRestaurantIdAndNameIgnoreCase(Long restaurantId, String name);

    // You can add more custom query methods here as needed.
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/model/Menu.java ===
package com.multirestaurantplatform.menu.model;

import com.multirestaurantplatform.common.model.BaseEntity;
import com.multirestaurantplatform.restaurant.model.Restaurant; // Import Restaurant
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "menus", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"restaurant_id", "name"}, name = "uq_menus_restaurant_id_name")
})
public class Menu extends BaseEntity {

    @NotBlank(message = "Menu name cannot be blank")
    @Size(min = 2, max = 100, message = "Menu name must be between 2 and 100 characters")
    @Column(nullable = false, length = 100)
    private String name;

    @Size(max = 500, message = "Description cannot exceed 500 characters")
    @Column(length = 500)
    private String description;

    @Column(nullable = false)
    private boolean isActive = true;

    @NotNull(message = "Menu must be associated with a restaurant")
    @ManyToOne(fetch = FetchType.LAZY) // Many menus can belong to one restaurant
    @JoinColumn(name = "restaurant_id", nullable = false) // Foreign key column in the 'menus' table
    private Restaurant restaurant;

    // toString, equals, and hashCode are inherited from BaseEntity (or can be customized if needed)
    // We might add @OneToMany for MenuSection later
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityService.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityService.java
package com.multirestaurantplatform.menu.service;

public interface MenuSecurityService {

    /**
     * Checks if the currently authenticated user (identified by username) has permission
     * to manage the specified menu.
     * This is typically used by RESTAURANT_ADMIN to ensure they only manage menus
     * belonging to restaurants they administer.
     *
     * @param menuId The ID of the menu to check.
     * @param username The username of the authenticated user (typically from `principal.username`).
     * @return true if the user is authorized to manage the menu, false otherwise.
     */
    boolean canManageMenu(Long menuId, String username);
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityServiceImpl.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuSecurityServiceImpl.java
package com.multirestaurantplatform.menu.service;

import com.multirestaurantplatform.menu.model.Menu;
import com.multirestaurantplatform.menu.repository.MenuRepository;
import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.service.RestaurantSecurityService; // Assuming this is the correct interface
import com.multirestaurantplatform.security.model.Role;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service("menuSecurityServiceImpl") // Explicit bean name for SpEL expression in @PreAuthorize
@RequiredArgsConstructor
public class MenuSecurityServiceImpl implements MenuSecurityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(MenuSecurityServiceImpl.class);

    private final MenuRepository menuRepository;
    private final UserRepository userRepository; // To fetch user roles
    private final RestaurantSecurityService restaurantSecurityService; // To check if user is admin for the restaurant

    @Override
    @Transactional(readOnly = true) // Read-only as it's a check operation
    public boolean canManageMenu(Long menuId, String username) {
        LOGGER.debug("SecurityCheck: Checking if user '{}' can manage menu ID '{}'", username, menuId);

        // 1. Fetch the user to check their roles
        Optional<User> userOptional = userRepository.findByUsername(username);
        if (userOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: User '{}' not found. Cannot manage menu.", username);
            return false;
        }
        User user = userOptional.get();

        // 2. Ensure the user has the RESTAURANT_ADMIN role.
        //    While @PreAuthorize("hasRole('RESTAURANT_ADMIN') and @bean.method()") handles the role check,
        //    it's good for this service to be aware or for standalone use.
        boolean isRestaurantAdminRole = user.getRoles().stream()
                .anyMatch(role -> role == Role.RESTAURANT_ADMIN);

        if (!isRestaurantAdminRole) {
            LOGGER.debug("SecurityCheck: User '{}' does not have RESTAURANT_ADMIN role. Cannot manage menu.", username);
            return false; // If not a RESTAURANT_ADMIN, they can't manage via this specific check.
                          // ADMIN role would be handled by a separate "hasRole('ADMIN')" in @PreAuthorize.
        }

        // 3. Fetch the menu
        Optional<Menu> menuOptional = menuRepository.findById(menuId);
        if (menuOptional.isEmpty()) {
            LOGGER.warn("SecurityCheck: Menu ID '{}' not found. Cannot determine management permission.", menuId);
            // If menu doesn't exist, access is implicitly denied for management.
            // The controller will likely throw a 404 separately.
            return false;
        }
        Menu menu = menuOptional.get();

        // 4. Get the restaurant associated with the menu
        Restaurant restaurant = menu.getRestaurant();
        if (restaurant == null) {
            LOGGER.error("SecurityCheck: Menu ID '{}' is not associated with any restaurant. Data integrity issue?", menuId);
            return false; // Should not happen in a consistent DB state
        }
        Long restaurantId = restaurant.getId();

        // 5. Delegate to RestaurantSecurityService to check if the user is an admin for this specific restaurant
        boolean isUserAdminForRestaurant = restaurantSecurityService.isRestaurantAdminForRestaurant(restaurantId, username);

        if (isUserAdminForRestaurant) {
            LOGGER.info("SecurityCheck: User '{}' IS an admin for restaurant ID '{}' (owner of menu ID '{}'). Access GRANTED by this check.", username, restaurantId, menuId);
        } else {
            LOGGER.info("SecurityCheck: User '{}' is NOT an admin for restaurant ID '{}' (owner of menu ID '{}'). Access DENIED by this check.", username, restaurantId, menuId);
        }

        return isUserAdminForRestaurant;
    }
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuService.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuService.java
package com.multirestaurantplatform.menu.service;

import com.multirestaurantplatform.menu.dto.CreateMenuRequestDto;
import com.multirestaurantplatform.menu.dto.MenuResponseDto;
import com.multirestaurantplatform.menu.dto.UpdateMenuRequestDto;

import java.util.List;

public interface MenuService {

    /**
     * Creates a new menu for a given restaurant.
     *
     * @param createMenuRequestDto DTO containing details for the new menu, including restaurantId.
     * @return MenuResponseDto of the created menu.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the specified restaurant does not exist.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if a menu with the same name already exists for the restaurant.
     */
    MenuResponseDto createMenu(CreateMenuRequestDto createMenuRequestDto);

    /**
     * Finds a menu by its unique ID.
     *
     * @param menuId The ID of the menu to find.
     * @return MenuResponseDto of the found menu.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the menu with the given ID is not found.
     */
    MenuResponseDto findMenuById(Long menuId);

    /**
     * Finds all menus associated with a specific restaurant ID.
     *
     * @param restaurantId The ID of the restaurant.
     * @return A list of MenuResponseDto for the specified restaurant.
     * Returns an empty list if the restaurant has no menus or does not exist (though ideally, check restaurant existence separately if needed).
     */
    List<MenuResponseDto> findMenusByRestaurantId(Long restaurantId);

    /**
     * Finds all active menus associated with a specific restaurant ID.
     *
     * @param restaurantId The ID of the restaurant.
     * @return A list of active MenuResponseDto for the specified restaurant.
     * Returns an empty list if the restaurant has no active menus.
     */
    List<MenuResponseDto> findActiveMenusByRestaurantId(Long restaurantId);

    /**
     * Updates an existing menu.
     *
     * @param menuId The ID of the menu to update.
     * @param updateMenuRequestDto DTO containing the fields to update. Null fields in DTO are ignored.
     * @return MenuResponseDto of the updated menu.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the menu with the given ID is not found.
     * @throws com.multirestaurantplatform.common.exception.ConflictException if updating the name causes a conflict with another menu in the same restaurant.
     */
    MenuResponseDto updateMenu(Long menuId, UpdateMenuRequestDto updateMenuRequestDto);

    /**
     * Deletes a menu by its ID.
     * This could be a hard delete or a soft delete (setting isActive to false).
     * The implementation will define the exact behavior.
     *
     * @param menuId The ID of the menu to delete.
     * @throws com.multirestaurantplatform.common.exception.ResourceNotFoundException if the menu with the given ID is not found (for hard delete scenarios).
     */
    void deleteMenu(Long menuId);
}
=== backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuServiceImpl.java ===
// File: backend/menu/src/main/java/com/multirestaurantplatform/menu/service/MenuServiceImpl.java
package com.multirestaurantplatform.menu.service;

import com.multirestaurantplatform.common.exception.ConflictException;
import com.multirestaurantplatform.common.exception.ResourceNotFoundException;
import com.multirestaurantplatform.menu.dto.CreateMenuRequestDto;
import com.multirestaurantplatform.menu.dto.MenuResponseDto;
import com.multirestaurantplatform.menu.dto.UpdateMenuRequestDto;
import com.multirestaurantplatform.menu.model.Menu;
import com.multirestaurantplatform.menu.repository.MenuRepository;
import com.multirestaurantplatform.restaurant.model.Restaurant; // Assuming this is the correct model
import com.multirestaurantplatform.restaurant.repository.RestaurantRepository; // Assuming this is the correct repository

import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class MenuServiceImpl implements MenuService {

    private static final Logger LOGGER = LoggerFactory.getLogger(MenuServiceImpl.class);

    private final MenuRepository menuRepository;
    private final RestaurantRepository restaurantRepository; // To validate restaurantId

    /**
     * Helper method to find a Menu entity by its ID or throw ResourceNotFoundException.
     * @param menuId The ID of the menu.
     * @return The found Menu entity.
     */
    private Menu findMenuEntityById(Long menuId) {
        return menuRepository.findById(menuId)
                .orElseThrow(() -> {
                    LOGGER.warn("Menu not found with ID: {}", menuId);
                    return new ResourceNotFoundException("Menu not found with ID: " + menuId);
                });
    }

    /**
     * Helper method to map a Menu entity to a MenuResponseDto.
     * @param menu The Menu entity.
     * @return The corresponding MenuResponseDto.
     */
    private MenuResponseDto mapToMenuResponseDto(Menu menu) {
        if (menu == null) {
            return null;
        }
        return new MenuResponseDto(
                menu.getId(),
                menu.getName(),
                menu.getDescription(),
                menu.isActive(),
                menu.getRestaurant() != null ? menu.getRestaurant().getId() : null, // Handle potential null restaurant
                menu.getCreatedAt(),
                menu.getUpdatedAt()
        );
    }

    @Override
    @Transactional
    public MenuResponseDto createMenu(CreateMenuRequestDto createMenuRequestDto) {
        LOGGER.info("Attempting to create menu with name: {} for restaurant ID: {}", createMenuRequestDto.getName(), createMenuRequestDto.getRestaurantId());

        // Validate that the restaurantId from the DTO corresponds to an existing Restaurant
        Restaurant restaurant = restaurantRepository.findById(createMenuRequestDto.getRestaurantId())
                .orElseThrow(() -> {
                    LOGGER.warn("Restaurant not found with ID: {} during menu creation", createMenuRequestDto.getRestaurantId());
                    return new ResourceNotFoundException("Restaurant not found with ID: " + createMenuRequestDto.getRestaurantId() + " while creating menu.");
                });

        // Check if a menu with the same name already exists for the given restaurant
        menuRepository.findByRestaurantIdAndNameIgnoreCase(createMenuRequestDto.getRestaurantId(), createMenuRequestDto.getName())
                .ifPresent(existingMenu -> {
                    LOGGER.warn("Menu creation failed: name '{}' already exists for restaurant ID {}.", createMenuRequestDto.getName(), createMenuRequestDto.getRestaurantId());
                    throw new ConflictException("Menu with name '" + createMenuRequestDto.getName() + "' already exists for this restaurant.");
                });

        Menu menu = new Menu();
        menu.setName(createMenuRequestDto.getName());
        menu.setDescription(createMenuRequestDto.getDescription());
        menu.setRestaurant(restaurant);
        menu.setActive(true); // Default to active

        Menu savedMenu = menuRepository.save(menu);
        LOGGER.info("Menu created successfully with ID: {}", savedMenu.getId());
        return mapToMenuResponseDto(savedMenu);
    }

    @Override
    @Transactional(readOnly = true)
    public MenuResponseDto findMenuById(Long menuId) {
        LOGGER.debug("Attempting to find menu with ID: {}", menuId);
        Menu menu = findMenuEntityById(menuId);
        return mapToMenuResponseDto(menu);
    }

    @Override
    @Transactional(readOnly = true)
    public List<MenuResponseDto> findMenusByRestaurantId(Long restaurantId) {
        LOGGER.debug("Fetching all menus for restaurant ID: {}", restaurantId);
        // Optional: Check if restaurant exists first if strict validation is needed before querying menus
        // if (!restaurantRepository.existsById(restaurantId)) {
        //     LOGGER.warn("Attempted to fetch menus for non-existent restaurant ID: {}", restaurantId);
        //     return Collections.emptyList(); // Or throw ResourceNotFoundException
        // }
        List<Menu> menus = menuRepository.findByRestaurantId(restaurantId);
        return menus.stream()
                .map(this::mapToMenuResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<MenuResponseDto> findActiveMenusByRestaurantId(Long restaurantId) {
        LOGGER.debug("Fetching active menus for restaurant ID: {}", restaurantId);
        List<Menu> activeMenus = menuRepository.findByRestaurantIdAndIsActiveTrue(restaurantId);
        return activeMenus.stream()
                .map(this::mapToMenuResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public MenuResponseDto updateMenu(Long menuId, UpdateMenuRequestDto updateMenuRequestDto) {
        LOGGER.info("Attempting to update menu with ID: {}", menuId);
        Menu menu = findMenuEntityById(menuId);

        // If name is being updated, check for name conflicts within the same restaurant
        if (StringUtils.hasText(updateMenuRequestDto.getName()) && !updateMenuRequestDto.getName().equalsIgnoreCase(menu.getName())) {
            menuRepository.findByRestaurantIdAndNameIgnoreCase(menu.getRestaurant().getId(), updateMenuRequestDto.getName())
                    .ifPresent(existingMenu -> {
                        if (!existingMenu.getId().equals(menuId)) { // Ensure it's not the same menu
                            LOGGER.warn("Menu update failed for ID {}: name '{}' already exists for restaurant ID {}.", menuId, updateMenuRequestDto.getName(), menu.getRestaurant().getId());
                            throw new ConflictException("Another menu with name '" + updateMenuRequestDto.getName() + "' already exists for this restaurant.");
                        }
                    });
            menu.setName(updateMenuRequestDto.getName());
        }

        if (updateMenuRequestDto.getDescription() != null) {
            menu.setDescription(updateMenuRequestDto.getDescription());
        }

        if (updateMenuRequestDto.getIsActive() != null) {
            menu.setActive(updateMenuRequestDto.getIsActive());
        }

        Menu updatedMenu = menuRepository.save(menu);
        LOGGER.info("Menu with ID: {} updated successfully.", updatedMenu.getId());
        return mapToMenuResponseDto(updatedMenu);
    }

    @Override
    @Transactional
    public void deleteMenu(Long menuId) {
        LOGGER.info("Attempting to soft delete menu with ID: {}", menuId);
        Menu menu = findMenuEntityById(menuId);

        if (!menu.isActive()) {
            LOGGER.info("Menu with ID: {} is already inactive.", menuId);
            // Optionally, you could throw an exception or just do nothing.
            // For now, we'll just log and proceed (idempotency for deactivation).
        }

        menu.setActive(false);
        menuRepository.save(menu);
        LOGGER.info("Menu with ID: {} soft deleted (set to inactive) successfully.", menuId);
        // For hard delete, it would be:
        // if (!menuRepository.existsById(menuId)) {
        //     throw new ResourceNotFoundException("Menu not found with ID: " + menuId + " for deletion.");
        // }
        // menuRepository.deleteById(menuId);
        // LOGGER.info("Menu with ID: {} hard deleted successfully.", menuId);
    }
}
=== backend/api/build.gradle ===
// File: multi-restaurant-platform/backend/api/build.gradle
plugins {
    id 'java' // Standard Java plugin
    id 'org.springframework.boot' // Apply Spring Boot plugin
}

description = 'The main API application module (Spring Boot)'

// Dependency Management is applied via allprojects in root build.gradle

dependencies {
    // --- Spring Boot Starters (Versions managed by BOM in root project) ---
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa' // Ensure JPA auto-config runs
    implementation 'org.springframework.boot:spring-boot-starter-validation'// For validation features
    implementation 'org.springframework.boot:spring-boot-starter-security' // Ensure Security auto-config runs

    // --- Database & Migration ---
    // H2 Database (Runtime only for local development/testing)
    runtimeOnly 'com.h2database:h2'
    // Flyway for Database Migrations (Version managed by BOM in root project)
    implementation 'org.flywaydb:flyway-core'

    // --- API Documentation (Version managed by dependencyManagement in root project) ---
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui'

    // --- Environment Variable Management ---
    // Library to load .env files. This allows us to use a .env file for local configuration.
    implementation 'io.github.cdimascio:dotenv-java:2.3.2' // Using version 2.3.2, ensure this is a recent stable version.

    // --- Local Module Dependencies ---
    implementation project(':backend:common')
    implementation project(':backend:security')
    implementation project(':backend:admin')
    // Add other modules as they become relevant and needed by the api module
    implementation project(':backend:restaurant')
    implementation project(':backend:menu')
    implementation project(':backend:order')
    implementation project(':backend:payment')
    implementation project(':backend:print')

    // --- Testing (Version managed by BOM in root project) ---
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test' // For @WithMockUser etc.


    // Lombok dependencies are managed in the root build.gradle
}

springBoot {
    mainClass = 'com.multirestaurantplatform.api.ApiApplication' // Verify this is your correct main class path
}

// If you plan to build executable JARs (default for Spring Boot)
bootJar {
    layered {
        enabled = true // Optimizes Docker image layering
    }
}
=== backend/api/src/main/resources/application.properties ===
# File: multi-restaurant-platform/backend/api/src/main/resources/application.properties

# Default Server Configuration
server.port=8081

# Application Name
spring.application.name=multi-restaurant-platform-backend

# --- H2 Database Console Settings (for development) ---
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# --- JPA / Hibernate Settings ---
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
# How Hibernate interacts with the schema. Set to 'validate' or 'none' when using Flyway.
# 'validate': Checks if the DB schema matches JPA entities on startup (good for catching mismatches).
# 'none': Trusts Flyway completely to manage the schema.
# Avoid 'create', 'create-drop', or 'update' when Flyway is active.
spring.jpa.hibernate.ddl-auto=validate
# --- Flyway Settings ---
spring.flyway.enabled=true
# spring.flyway.locations=classpath:db/migration # Default location

# --- SpringDoc OpenAPI (Swagger UI) Configuration ---
# springdoc.swagger-ui.path=/swagger-ui.html
# springdoc.api-docs.path=/v3/api-docs

# --- JWT Configuration ---
# The JWT secret key is read from the JWT_SECRET_KEY environment variable.
# This variable is loaded from the .env file by dotenv-java during local development.
app.jwt.secret=${JWT_SECRET_KEY:fallback-secret-for-testing-only-if-env-is-missing-replace-or-remove-for-prod}

# Token validity duration in milliseconds. Example: 1 hour = 3600000 ms.
app.jwt.expiration-ms=3600000

# Standard prefix for the JWT in the Authorization header (e.g., "Bearer <token>"). Note the space at the end.
app.jwt.token-prefix=Bearer

# --- Logging Configuration ---
logging.level.com.multirestaurantplatform.security=DEBUG
=== backend/api/src/main/resources/db/migration/V1__Initial_Schema.sql ===
=== backend/api/src/main/resources/db/migration/V2__Create_Restaurant_Tables.sql ===
=== backend/api/src/main/resources/db/migration/V3__Create_Menu_Table.sql ===
=== backend/api/src/main/resources/db/migration/V4__Create_Order_Tables.sql ===
=== backend/api/src/main/resources/db/migration/V5__Add_OutForDeliveryAt_To_Orders.sql ===
=== backend/api/src/main/java/com/multirestaurantplatform/api/ApiApplication.java ===
// File: backend/api/src/main/java/com/multirestaurantplatform/api/ApiApplication.java
package com.multirestaurantplatform.api;

import io.github.cdimascio.dotenv.Dotenv;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

// scanBasePackages in @SpringBootApplication should cover all your modules' services, components, etc.
// The value "com.multirestaurantplatform" is broad enough to cover all your sub-modules.
@SpringBootApplication(scanBasePackages = "com.multirestaurantplatform")
@EnableJpaRepositories(basePackages = {
        "com.multirestaurantplatform.security.repository",
        "com.multirestaurantplatform.restaurant.repository",
        "com.multirestaurantplatform.menu.repository",
        "com.multirestaurantplatform.order.repository" // Added OrderRepository package
})
@EntityScan(basePackages = {
        "com.multirestaurantplatform.security.model",
        "com.multirestaurantplatform.common.model",    // BaseEntity is here
        "com.multirestaurantplatform.restaurant.model",
        "com.multirestaurantplatform.menu.model",
        "com.multirestaurantplatform.order.model"      // Added Order and OrderItem entity package
})
public class ApiApplication {

    public static void main(String[] args) {
        // Load environment variables from .env file, primarily for local development
        Dotenv dotenv = Dotenv.configure()
                .directory("../../") // Path from backend/api to project root where .env might be
                .filename(".env")    // Explicitly specify the filename
                .ignoreIfMissing()   // Don't throw an error if .env is not found
                .ignoreIfMalformed() // Don't throw an error if .env is malformed
                .load();

        // Example: Set JWT_SECRET_KEY as a system property if found in .env
        // This allows @Value("${JWT_SECRET_KEY}") to pick it up.
        String loadedSecret = dotenv.get("JWT_SECRET_KEY");
        if (loadedSecret != null && !loadedSecret.trim().isEmpty()) {
            System.setProperty("JWT_SECRET_KEY", loadedSecret);
            // For debugging: System.out.println("Loaded JWT_SECRET_KEY from .env and set as system property.");
        } else {
            // For debugging: System.out.println("JWT_SECRET_KEY not found in .env or is empty.");
        }

        // Ensure other .env variables are similarly propagated if needed as system properties
        // or accessed directly via dotenv instance in specific configurations.

        SpringApplication.run(ApiApplication.class, args);
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/dto/error/ErrorResponse.java ===
package com.multirestaurantplatform.api.dto.error;

import java.time.LocalDateTime;

public record ErrorResponse(
    LocalDateTime timestamp,
    int status,
    String error, // Short error description e.g., "Not Found", "Bad Request"
    String message, // Detailed error message from the exception
    String path // The request path
) {
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/config/OpenApiConfig.java ===
package com.multirestaurantplatform.api.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Collections; // Import Collections

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        final String securitySchemeName = "bearerAuth"; // Define the security scheme name

        return new OpenAPI()
                .info(new Info()
                        .title("Multi-Restaurant Platform API")
                        .version("1.0")
                        .description("API documentation for the Multi-Restaurant Platform Backend"))
                .addSecurityItem(new SecurityRequirement().addList(securitySchemeName, Collections.emptyList())) // Use addList with empty scopes
                .components(new Components()
                        .addSecuritySchemes(securitySchemeName, new SecurityScheme() // Use the defined name
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")
                                .description("Enter JWT token in the format 'Bearer <token>'")
                        ));
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/HealthCheckController.java ===
package com.multirestaurantplatform.api.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize; // For method-level security
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/test") // Changed base path for clarity, or keep /health and add new mapping
public class HealthCheckController { // Renaming to TestController might be better if adding more test endpoints

    @GetMapping("/health") // This remains public as per SecurityConfig
    public Map<String, String> checkHealth() {
        return Collections.singletonMap("status", "UP");
    }

    // New SECURED endpoint
    @GetMapping("/secure-data")
    // @PreAuthorize("isAuthenticated()") // Alternative: method-level security if @EnableMethodSecurity is on SecurityConfig
    public ResponseEntity<Map<String, Object>> getSecureData() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = "anonymous";

        if (authentication != null && authentication.getPrincipal() instanceof UserDetails) {
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            username = userDetails.getUsername();
        } else if (authentication != null) {
            username = authentication.getName();
        }

        Map<String, Object> data = new HashMap<>();
        data.put("message", "This is secured data for authenticated users.");
        data.put("user", username);
        data.put("authorities", authentication != null ? authentication.getAuthorities() : Collections.emptyList());

        return ResponseEntity.ok(data);
    }

    // Example of an admin-only endpoint (requires @EnableMethodSecurity in SecurityConfig)
    @GetMapping("/admin-only")
    @PreAuthorize("hasRole('ADMIN')") // Ensure your roles are prefixed with ROLE_ in UserDetails authorities, or use hasAuthority('ADMIN')
    public ResponseEntity<String> getAdminData() {
        return ResponseEntity.ok("This is data only for users with the ADMIN role.");
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/MenuController.java ===
// File: backend/api/src/main/java/com/multirestaurantplatform/api/controller/MenuController.java
package com.multirestaurantplatform.api.controller;

import com.multirestaurantplatform.menu.dto.CreateMenuRequestDto;
import com.multirestaurantplatform.menu.dto.MenuResponseDto;
import com.multirestaurantplatform.menu.dto.UpdateMenuRequestDto;
import com.multirestaurantplatform.menu.service.MenuService;
// Import MenuSecurityService if you need to inject its bean, though for SpEL it's usually not directly injected here
// import com.multirestaurantplatform.menu.service.MenuSecurityService;
// Import RestaurantSecurityService if you need to inject its bean for SpEL usage
// import com.multirestaurantplatform.restaurant.service.RestaurantSecurityService;


import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/menus")
@RequiredArgsConstructor
@Tag(name = "Menu Management", description = "APIs for managing restaurant menus")
@SecurityRequirement(name = "bearerAuth") // Indicates JWT is generally required
public class MenuController {

    private static final Logger LOGGER = LoggerFactory.getLogger(MenuController.class);
    private final MenuService menuService;
    // No need to inject security services here if they are only used in @PreAuthorize SpEL expressions
    // and are correctly named Spring beans (e.g., @Service("menuSecurityServiceImpl"))

    @PostMapping
    // This PreAuthorize assumes restaurantSecurityServiceImpl is a bean named "restaurantSecurityServiceImpl"
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @restaurantSecurityServiceImpl.isRestaurantAdminForRestaurant(#createMenuRequestDto.restaurantId, principal.username))")
    @Operation(summary = "Create a new menu",
            description = "Creates a new menu for a specified restaurant. Requires ADMIN role or RESTAURANT_ADMIN role for the target restaurant.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Menu created successfully",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Invalid input data",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized - JWT token is missing or invalid",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "403", description = "Forbidden - User does not have necessary permissions",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Restaurant not found",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "409", description = "Conflict - Menu name already exists for the restaurant",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<MenuResponseDto> createMenu(
            @Valid @RequestBody CreateMenuRequestDto createMenuRequestDto) {
        LOGGER.info("API call to create menu: {} for restaurant ID: {}", createMenuRequestDto.getName(), createMenuRequestDto.getRestaurantId());
        MenuResponseDto createdMenu = menuService.createMenu(createMenuRequestDto);
        LOGGER.info("Menu created with ID: {}", createdMenu.getId());
        return new ResponseEntity<>(createdMenu, HttpStatus.CREATED);
    }

    @GetMapping("/{menuId}")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get a menu by ID",
            description = "Retrieves details of a specific menu by its ID. Accessible by any authenticated user.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Menu found",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Menu not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<MenuResponseDto> getMenuById(
            @Parameter(description = "ID of the menu to be retrieved") @PathVariable Long menuId) {
        LOGGER.debug("API call to get menu by ID: {}", menuId);
        MenuResponseDto menu = menuService.findMenuById(menuId);
        return ResponseEntity.ok(menu);
    }

    @GetMapping("/by-restaurant/{restaurantId}")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get all menus for a restaurant",
            description = "Retrieves a list of all menus for a specific restaurant. Accessible by any authenticated user.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "List of menus retrieved",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))), // Assuming list response
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
            })
    public ResponseEntity<List<MenuResponseDto>> getMenusByRestaurantId(
            @Parameter(description = "ID of the restaurant whose menus are to be retrieved") @PathVariable Long restaurantId) {
        LOGGER.debug("API call to get all menus for restaurant ID: {}", restaurantId);
        List<MenuResponseDto> menus = menuService.findMenusByRestaurantId(restaurantId);
        return ResponseEntity.ok(menus);
    }

    @GetMapping("/by-restaurant/{restaurantId}/active")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get active menus for a restaurant",
            description = "Retrieves a list of active menus for a specific restaurant. Accessible by any authenticated user.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "List of active menus retrieved",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
            })
    public ResponseEntity<List<MenuResponseDto>> getActiveMenusByRestaurantId(
            @Parameter(description = "ID of the restaurant whose active menus are to be retrieved") @PathVariable Long restaurantId) {
        LOGGER.debug("API call to get active menus for restaurant ID: {}", restaurantId);
        List<MenuResponseDto> activeMenus = menuService.findActiveMenusByRestaurantId(restaurantId);
        return ResponseEntity.ok(activeMenus);
    }

    @PutMapping("/{menuId}")
    // Updated PreAuthorize to use menuSecurityServiceImpl
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @menuSecurityServiceImpl.canManageMenu(#menuId, principal.username))")
    @Operation(summary = "Update an existing menu",
            description = "Updates details of an existing menu. Requires ADMIN role, or RESTAURANT_ADMIN role for the restaurant owning the menu.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Menu updated successfully",
                            content = @Content(mediaType = "application/json", schema = @Schema(implementation = MenuResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Invalid input data", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Menu not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "409", description = "Conflict - Updated name already exists for the restaurant", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<MenuResponseDto> updateMenu(
            @Parameter(description = "ID of the menu to be updated") @PathVariable Long menuId,
            @Valid @RequestBody UpdateMenuRequestDto updateMenuRequestDto) {
        LOGGER.info("API call to update menu with ID: {}", menuId);
        MenuResponseDto updatedMenu = menuService.updateMenu(menuId, updateMenuRequestDto);
        LOGGER.info("Menu with ID: {} updated successfully", updatedMenu.getId());
        return ResponseEntity.ok(updatedMenu);
    }

    @DeleteMapping("/{menuId}")
    // Updated PreAuthorize to use menuSecurityServiceImpl
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @menuSecurityServiceImpl.canManageMenu(#menuId, principal.username))")
    @Operation(summary = "Delete a menu by ID (Soft Delete)",
            description = "Soft deletes a menu by its ID (sets isActive to false). Requires ADMIN role, or RESTAURANT_ADMIN role for the restaurant owning the menu.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Menu deleted successfully (set to inactive)"),
                    @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                    @ApiResponse(responseCode = "404", description = "Menu not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
            })
    public ResponseEntity<Void> deleteMenu(
            @Parameter(description = "ID of the menu to be deleted") @PathVariable Long menuId) {
        LOGGER.info("API call to delete menu with ID: {}", menuId);
        menuService.deleteMenu(menuId);
        LOGGER.info("Menu with ID: {} soft deleted successfully", menuId);
        return ResponseEntity.noContent().build();
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/RestaurantController.java ===
package com.multirestaurantplatform.api.controller;

import com.multirestaurantplatform.restaurant.dto.CreateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.dto.RestaurantResponseDto;
import com.multirestaurantplatform.restaurant.dto.UpdateRestaurantRequestDto;
import com.multirestaurantplatform.restaurant.model.Restaurant;
import com.multirestaurantplatform.restaurant.service.RestaurantService;
// Import your custom security service if you create one for method-level checks
// import com.multirestaurantplatform.security.service.RestaurantSecurityService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/restaurants")
@RequiredArgsConstructor
@Tag(name = "Restaurant Management", description = "APIs for managing restaurants")
@SecurityRequirement(name = "bearerAuth") // Indicates that JWT is required for these endpoints by default
public class RestaurantController {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestaurantController.class);
    private final RestaurantService restaurantService;
    // Uncomment if you implement RestaurantSecurityService for custom authorization
    // private final RestaurantSecurityService restaurantSecurityService;


    // Helper method to map Restaurant Entity to RestaurantResponseDto
    private RestaurantResponseDto mapToRestaurantResponseDto(Restaurant restaurant) {
        if (restaurant == null) {
            return null;
        }
        return new RestaurantResponseDto(
                restaurant.getId(),
                restaurant.getName(),
                restaurant.getDescription(),
                restaurant.getAddress(),
                restaurant.getPhoneNumber(),
                restaurant.getEmail(),
                restaurant.isActive(),
                restaurant.getCreatedAt(),
                restaurant.getUpdatedAt()
        );
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Create a new restaurant",
               description = "Creates a new restaurant. Requires ADMIN role.",
               responses = {
                   @ApiResponse(responseCode = "201", description = "Restaurant created successfully",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "400", description = "Invalid input data (e.g., validation error)", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized - JWT token is missing or invalid", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden - User does not have ADMIN role", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "409", description = "Conflict - Restaurant name or email already exists", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<RestaurantResponseDto> createRestaurant(
            @Valid @RequestBody CreateRestaurantRequestDto createDto) {
        LOGGER.info("API call to create restaurant with name: {}", createDto.getName());
        Restaurant createdRestaurant = restaurantService.createRestaurant(createDto);
        LOGGER.info("Restaurant created with ID: {}", createdRestaurant.getId());
        return new ResponseEntity<>(mapToRestaurantResponseDto(createdRestaurant), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("isAuthenticated()") // Allows any authenticated user to view restaurant details. Adjust if needed.
    @Operation(summary = "Get a restaurant by ID",
               description = "Retrieves details of a specific restaurant by its ID. Accessible by any authenticated user.",
               responses = {
                   @ApiResponse(responseCode = "200", description = "Restaurant found",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden (if specific role checks were added and failed)", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "404", description = "Restaurant not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<RestaurantResponseDto> getRestaurantById(@PathVariable Long id) {
        LOGGER.debug("API call to get restaurant by ID: {}", id);
        Restaurant restaurant = restaurantService.findRestaurantById(id);
        return ResponseEntity.ok(mapToRestaurantResponseDto(restaurant));
    }

    @GetMapping
    @PreAuthorize("isAuthenticated()") // Allows any authenticated user to list restaurants.
    @Operation(summary = "Get all restaurants",
               description = "Retrieves a list of all restaurants. Accessible by any authenticated user. (Pagination to be added later)",
               responses = {
                   @ApiResponse(responseCode = "200", description = "List of restaurants retrieved",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<List<RestaurantResponseDto>> getAllRestaurants() {
        // TODO: Implement pagination (e.g., using Pageable) and filtering
        LOGGER.debug("API call to get all restaurants");
        List<Restaurant> restaurants = restaurantService.findAllRestaurants();
        List<RestaurantResponseDto> responseDtos = restaurants.stream()
                .map(this::mapToRestaurantResponseDto)
                .collect(Collectors.toList());
        return ResponseEntity.ok(responseDtos);
    }

    @PutMapping("/{id}")
    // Option 1: Simple ADMIN only
    // @PreAuthorize("hasRole('ADMIN')")
    // Option 2: ADMIN or specific RESTAURANT_ADMIN (requires custom RestaurantSecurityService)
    @PreAuthorize("hasRole('ADMIN') or (hasRole('RESTAURANT_ADMIN') and @restaurantSecurityServiceImpl.isRestaurantAdminForRestaurant(#id, principal.username))")
    @Operation(summary = "Update an existing restaurant",
               description = "Updates details of an existing restaurant. Requires ADMIN role, or RESTAURANT_ADMIN role for the specific restaurant if `RestaurantSecurityService` is implemented.",
               responses = {
                   @ApiResponse(responseCode = "200", description = "Restaurant updated successfully",
                                content = @Content(mediaType = "application/json", schema = @Schema(implementation = RestaurantResponseDto.class))),
                   @ApiResponse(responseCode = "400", description = "Invalid input data", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "404", description = "Restaurant not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "409", description = "Conflict - Updated name or email already exists", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<RestaurantResponseDto> updateRestaurant(
            @PathVariable Long id,
            @Valid @RequestBody UpdateRestaurantRequestDto updateDto) {
        LOGGER.info("API call to update restaurant with ID: {}", id);
        Restaurant updatedRestaurant = restaurantService.updateRestaurant(id, updateDto);
        LOGGER.info("Restaurant with ID: {} updated successfully", updatedRestaurant.getId());
        return ResponseEntity.ok(mapToRestaurantResponseDto(updatedRestaurant));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Delete a restaurant by ID",
               description = "Deletes a specific restaurant by its ID. Requires ADMIN role.",
               responses = {
                   @ApiResponse(responseCode = "204", description = "Restaurant deleted successfully"),
                   @ApiResponse(responseCode = "401", description = "Unauthorized", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "403", description = "Forbidden - User does not have ADMIN role", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class))),
                   @ApiResponse(responseCode = "404", description = "Restaurant not found", content = @Content(mediaType = "application/json", schema = @Schema(implementation = com.multirestaurantplatform.api.dto.error.ErrorResponse.class)))
               })
    public ResponseEntity<Void> deleteRestaurant(@PathVariable Long id) {
        LOGGER.info("API call to delete restaurant with ID: {}", id);
        restaurantService.deleteRestaurant(id);
        LOGGER.info("Restaurant with ID: {} deleted successfully", id);
        return ResponseEntity.noContent().build();
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/UserController.java ===
package com.multirestaurantplatform.api.controller;

import com.multirestaurantplatform.security.dto.UserResponseDto;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/users") // Base path for user-related endpoints
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    // Endpoint to get a user by username
    @GetMapping("/username/{username}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponseDto> getUserByUsername(@PathVariable String username) {
        User user = userService.findUserByUsername(username);
        UserResponseDto userResponseDto = mapToUserResponseDto(user);
        return ResponseEntity.ok(userResponseDto);
    }

    // New Endpoint: Get a user by ID
    @GetMapping("/id/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponseDto> getUserById(@PathVariable Long id) {
        User user = userService.findUserById(id);
        UserResponseDto userResponseDto = mapToUserResponseDto(user);
        return ResponseEntity.ok(userResponseDto);
    }

    // New Endpoint: Get a user by email
    @GetMapping("/email/{email}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponseDto> getUserByEmail(@PathVariable String email) {
        User user = userService.findUserByEmail(email); // Assuming email path variable should be URL-friendly
        // For emails, sometimes using a request param is preferred
        // e.g., /users/search?email=user@example.com
        // But /email/{email} is also common.
        UserResponseDto userResponseDto = mapToUserResponseDto(user);
        return ResponseEntity.ok(userResponseDto);
    }

    // Helper method to map User entity to UserResponseDto
    private UserResponseDto mapToUserResponseDto(User user) {
        if (user == null) {
            return null; // Should not happen if service throws ResourceNotFoundException
        }
        return new UserResponseDto(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getRoles()
        );
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/controller/auth/AuthController.java ===
package com.multirestaurantplatform.api.controller.auth;

import com.multirestaurantplatform.security.dto.JwtAuthenticationResponse;
import com.multirestaurantplatform.security.dto.LoginRequest;
import com.multirestaurantplatform.security.dto.RegisterRequest;
import com.multirestaurantplatform.security.model.User;
import com.multirestaurantplatform.security.service.JwtService;
import com.multirestaurantplatform.security.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/auth") // Base path for authentication-related endpoints
@RequiredArgsConstructor // Lombok: Creates constructor for all final fields
public class AuthController {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuthController.class);

    private final UserService userService;
    private final AuthenticationManager authenticationManager; // For authenticating users
    private final JwtService jwtService;                     // For generating JWT tokens

    // In AuthController.java
    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@Valid @RequestBody RegisterRequest registerRequest) {
        // Remove the try-catch block for RuntimeException
        User registeredUser = userService.registerUser(registerRequest); // Let exceptions propagate

        // Consider returning a different DTO instead of the full User entity to avoid exposing too much.
        // For now, a success message or a simplified representation is fine.
        LOGGER.info("User registered successfully: {}", registeredUser.getUsername());

        // For consistency, you might want to consider returning a JSON response even for success.
        // Example:
        // Map<String, String> responseBody = Map.of("message", "User registered successfully with username: " + registeredUser.getUsername());
        // return ResponseEntity.status(HttpStatus.CREATED).body(responseBody);
        return ResponseEntity.status(HttpStatus.CREATED).body("User registered successfully with username: " + registeredUser.getUsername());
    }

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        try {
            // Attempt to authenticate the user using Spring Security's AuthenticationManager
            // This will use your UserDetailsServiceImpl to load the user and check credentials
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()
                    )
            );

            // If authentication is successful, set the authentication in the SecurityContext
            SecurityContextHolder.getContext().setAuthentication(authentication);

            // The principal is now an instance of UserDetails (as returned by your UserDetailsServiceImpl)
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();

            // Generate JWT token using our JwtService
            String jwt = jwtService.generateToken(userDetails);

            LOGGER.info("User authenticated successfully: {}", userDetails.getUsername());
            // Return the JWT in the response
            return ResponseEntity.ok(new JwtAuthenticationResponse(jwt));

        } catch (BadCredentialsException e) {
            LOGGER.warn("Authentication failed for user {}: Invalid credentials", loginRequest.getUsername());
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Error: Invalid username or password");
        } catch (Exception e) {
            LOGGER.error("Authentication error for user {}: {}", loginRequest.getUsername(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: An internal server error occurred during authentication.");
        }
    }
}
=== backend/api/src/main/java/com/multirestaurantplatform/api/exception/GlobalExceptionHandler.java ===
package com.multirestaurantplatform.api.exception;

// ... other imports
import com.multirestaurantplatform.common.exception.BadRequestException; // Added
import com.multirestaurantplatform.common.exception.ConflictException; // Added
import com.multirestaurantplatform.common.exception.ResourceNotFoundException; // Added
import com.multirestaurantplatform.api.dto.error.ErrorResponse; // Added

import com.multirestaurantplatform.order.exception.IllegalOrderStateException;
import jakarta.servlet.http.HttpServletRequest; // Added if not present, or use WebRequest
import org.slf4j.Logger; // Added
import org.slf4j.LoggerFactory; // Added
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
// ...

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    private static final Logger customLogger = LoggerFactory.getLogger(GlobalExceptionHandler.class); // Renamed to avoid conflict if 'logger' is in parent

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers,
            HttpStatusCode status, WebRequest request) {

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now().toString()); // Consider LocalDateTime directly if ErrorResponse is adapted
        body.put("status", status.value());
        body.put("error", "Bad Request"); // Or HttpStatus.BAD_REQUEST.getReasonPhrase()

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());
        body.put("errors", errors); // This "errors" field is specific to validation

        String path = "";
        if (request != null && request.getDescription(false) != null) {
            path = request.getDescription(false).replace("uri=", "");
            body.put("path", path);
        }
        customLogger.warn("MethodArgumentNotValidException: {} errors for path {}: {}", ex.getBindingResult().getErrorCount(), path, errors);
        return new ResponseEntity<>(body, headers, status);
    }

    // --- New Handlers for Custom Exceptions ---

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(
            ResourceNotFoundException ex, HttpServletRequest request) { // Using HttpServletRequest for simplicity here
        customLogger.warn("ResourceNotFoundException: {} at path {}", ex.getMessage(), request.getRequestURI());
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.NOT_FOUND.value(),
                HttpStatus.NOT_FOUND.getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(
            BadRequestException ex, HttpServletRequest request) {
        customLogger.warn("BadRequestException: {} at path {}", ex.getMessage(), request.getRequestURI());
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                HttpStatus.BAD_REQUEST.getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(
            ConflictException ex, HttpServletRequest request) {
        customLogger.warn("ConflictException: {} at path {}", ex.getMessage(), request.getRequestURI());
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.CONFLICT.value(),
                HttpStatus.CONFLICT.getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(
            AccessDeniedException ex, HttpServletRequest request) {
        customLogger.warn("AccessDeniedException: {} for path {}", ex.getMessage(), request.getRequestURI()); // Log as WARN or INFO
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.FORBIDDEN.value(),
                HttpStatus.FORBIDDEN.getReasonPhrase(),
                "Access Denied: You do not have the necessary permissions to access this resource.", // Or ex.getMessage() if you prefer
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // --- Fallback Handler ---
    // This handles any other exceptions not specifically caught above or by ResponseEntityExceptionHandler
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex, HttpServletRequest request) {
        // Avoid logging known Spring Security exceptions like AccessDeniedException twice if already handled by Spring Security
        // Or if you have specific handlers for them
        customLogger.error("Unhandled Exception: {} at path {}", ex.getMessage(), request.getRequestURI(), ex);
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "An unexpected internal server error occurred.", // Generic message to client
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(IllegalOrderStateException.class)
    public ResponseEntity<ErrorResponse> handleIllegalOrderStateException(
            IllegalOrderStateException ex, HttpServletRequest request) {
        customLogger.warn("IllegalOrderStateException: {} at path {}", ex.getMessage(), request.getRequestURI());
        ErrorResponse errorResponse = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.CONFLICT.value(), // 409 Conflict is appropriate for invalid state transition
                HttpStatus.CONFLICT.getReasonPhrase(),
                ex.getMessage(),
                request.getRequestURI());
        return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
    }
}
=== gradle/wrapper/gradle-wrapper.jar ===
=== gradle/wrapper/gradle-wrapper.properties ===
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
LLM Instructions:
Hello LLM, I need your assistance in developing and improving my application while being careful not breaking the current working app. The project already been started and is progressing. the "Multi‚ÄëRestaurant Platform." I will guide ‚Ä¶ (full block omitted for brevity in code; emitted verbatim at the end). analyze the attached file and decide for the next step. Put modules, paths, every java class, interface, implementation, application. properties, build.gradle files etc. that are critical for the project into your memory. Always give full path of the files at beginning. always ask before proceeding. Always with small steps. each step should include a feature change, an automation testing and git commit message. 